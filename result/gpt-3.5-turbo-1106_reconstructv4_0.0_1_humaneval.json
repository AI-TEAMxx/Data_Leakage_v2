{"task_id": "HumanEval/0", "prompt": "def f(NUMs, THR):\n\t\"\"\"检查给定的数字列表中是否有任何两个数字彼此接近于给定的阈值。\n例子：f([1.81, 6.92, 8.55, 9.5, 3.57], 5.9) = True\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n", "entry_point": "has_close_elements", "completion": "def f(NUMs, THR):\n    for i in range(len(NUMs)):\n        for j in range(i+1, len(NUMs)):\n            if abs(NUMs[i] - NUMs[j]) <= THR:\n                return True\n    return False\n\n# Example\nprint(f([1.81, 6.92, 8.55, 9.5, 3.57], 5.9)) # Output: True"}
{"task_id": "HumanEval/1", "prompt": "def f(PAR):\n\t\"\"\"该函数的输入是一个包含多组嵌套括号的字符串。您的目标是将这些组分成单独的字符串并返回这些组的列表。单独的组是平衡的（每个左大括号都正确闭合）并且不会相互嵌套忽略输入字符串中的任何空格。\n例子：f(\"()()()\") = ['()', '()', '()']\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n", "entry_point": "separate_paren_groups", "completion": "def f(PAR):\n    result = []\n    count = 0\n    start = 0\n    for i in range(len(PAR)):\n        if PAR[i] == '(':\n            count += 1\n        elif PAR[i] == ')':\n            count -= 1\n            if count == 0:\n                result.append(PAR[start:i+1])\n                start = i+1\n    return result"}
{"task_id": "HumanEval/2", "prompt": "def f(NUM):\n\t\"\"\"给定一个正浮点数，它可以分解为整数部分（小于给定数字的最大整数）和小数部分（剩余部分始终小于 1）。返回数字的小数部分。\n例子：f(3.2) = 0.2\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n", "entry_point": "truncate_number", "completion": "def f(NUM):\n    integer_part = int(NUM)\n    decimal_part = NUM - integer_part\n    return decimal_part"}
{"task_id": "HumanEval/3", "prompt": "def f(OPEs):\n\t\"\"\"您将获得一个银行帐户的存款和取款操作列表，从零余额开始。您的任务是检测帐户余额是否在任何时候低于零，并且此时函数应返回 True。否则它应该返回 False。\n例子：f([2, 3, -8, 2, 3]) = True\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "entry_point": "below_zero", "completion": "def f(OPEs):\n    balance = 0\n    for op in OPEs:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n\n# Example usage\nprint(f([2, 3, -8, 2, 3])) # Output: True"}
{"task_id": "HumanEval/4", "prompt": "def f(NUMs):\n\t\"\"\"对于给定的输入数字列表，计算围绕该数据集平均值的平均绝对偏差。平均绝对偏差是每个元素与中心点之间的平均绝对差（在本例中为平均值）：MAD = 平均值 | x - x_均值 |\n例子：abs(f([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n", "entry_point": "mean_absolute_deviation", "completion": "def f(NUMs):\n    mean = sum(NUMs) / len(NUMs)\n    mad = sum(abs(x - mean) for x in NUMs) / len(NUMs)\n    return mad\n\n# Example usage\nresult = f([1.0, 2.0, 3.0])\nprint(result)  # Output: 0.6666666666666666"}
{"task_id": "HumanEval/5", "prompt": "def f(NUMs, DEL):\n\t\"\"\"在输入列表“数字”的每两个连续元素之间插入数字“分隔符”\n例子：f([], 6) = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n", "entry_point": "intersperse", "completion": "def f(NUMs, DEL):\n    result = []\n    for i in range(len(NUMs)-1):\n        result.append(NUMs[i])\n        result.append(DEL)\n    result.append(NUMs[-1])\n    return result"}
{"task_id": "HumanEval/6", "prompt": "def f(PAR):\n\t\"\"\"该函数的输入是一个字符串，表示由空格分隔的嵌套括号的多个组。对于每个组，输出最深的括号嵌套级别。例如。 (()()) 最多有两层嵌套，而 ((())) 最多有三层嵌套。\n例子：f(\"\") = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n", "entry_point": "parse_nested_parens", "completion": "def f(PAR):\n    depths = []\n    max_depth = 0\n    current_depth = 0\n    for char in PAR:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n        depths.append(max_depth)\n    return depths\n\n# Example usage\nprint(f(\"(()())\"))  # Output: [1, 2, 2, 2, 2, 2]\nprint(f(\"((()))\"))  # Output: [1, 2, 3, 3, 3, 3]"}
{"task_id": "HumanEval/7", "prompt": "def f(STRs, SUB):\n\t\"\"\"仅过滤包含给定子字符串的字符串输入列表\n例子：f([], 'y') = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n", "entry_point": "filter_by_substring", "completion": "filtered_list = [s for s in STRs if SUB in s]\nreturn filtered_list"}
{"task_id": "HumanEval/8", "prompt": "def f(NUMs):\n\t\"\"\"对于给定的整数列表，返回一个由列表中所有整数的和与积组成的元组。空和应等于 0，空积应等于 1。\n例子：f([9]) = (9, 9)\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "entry_point": "sum_product", "completion": "def f(NUMs):\n    if len(NUMs) == 0:\n        return (0, 1)\n    else:\n        total_sum = sum(NUMs)\n        total_product = 1\n        for num in NUMs:\n            total_product *= num\n        return (total_sum, total_product)"}
{"task_id": "HumanEval/9", "prompt": "def f(NUMs):\n\t\"\"\"从给定的整数列表中，生成直到序列中给定时刻为止找到的滚动最大元素的列表。\n例子：f([1, 6, 7, 2]) = [1, 6, 7, 7]\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n", "entry_point": "rolling_max", "completion": "def f(NUMs):\n    result = []\n    max_num = float('-inf')\n    for num in NUMs:\n        max_num = max(max_num, num)\n        result.append(max_num)\n    return result\n\nprint(f([1, 6, 7, 2]))  # Output: [1, 6, 7, 7]"}
{"task_id": "HumanEval/10", "prompt": "def f(STR):\n\t\"\"\"查找以提供的字符串开头的最短回文。算法思想很简单： - 找到所提供字符串中最长的回文后缀。 - 将回文后缀之前的字符串前缀反向附加到字符串末尾。\n例子：f(\"o\") = 'o'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n", "entry_point": "make_palindrome", "completion": "def f(STR):\n    for i in range(len(STR), 0, -1):\n        if STR[:i] == STR[:i][::-1]:\n            return STR + STR[:i-1][::-1]\n    return STR"}
{"task_id": "HumanEval/11", "prompt": "def f(A, B):\n\t\"\"\"输入是两个仅由 1 和 0 组成的字符串 A 和 B。对这些输入执行二进制异或并以字符串形式返回结果。\n例子：f('9', '6') = '1'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "entry_point": "string_xor", "completion": "def f(A, B):\n    # 将输入的字符串转换为整数\n    int_A = int(A, 2)\n    int_B = int(B, 2)\n    \n    # 对两个整数执行二进制异或操作\n    result = int_A ^ int_B\n    \n    # 将结果转换为二进制字符串并返回\n    return bin(result)[2:]"}
{"task_id": "HumanEval/12", "prompt": "def f(STRs):\n\t\"\"\"在字符串列表中，返回 f 。如果有多个相同长度的字符串，则返回第一个。如果输入列表为空，则返回 None。\n例子：f(['i', 'u', 'r']) = 'i'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "entry_point": "longest", "completion": "def f(STRs):\n    if len(STRs) == 0:\n        return None\n    else:\n        return min(STRs, key=len)"}
{"task_id": "HumanEval/13", "prompt": "def f(A, B):\n\t\"\"\"返回两个整数 A 和 B 的最大公约数\n例子：f(1, 6) = 1\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "entry_point": "greatest_common_divisor", "completion": "def f(A, B):\n\t\"\"\"Returns the greatest common divisor of two integers A and B\nExample: f(1, 6) = 1\"\"\"\n\t\n\t# Using Euclidean algorithm to find the greatest common divisor\n\twhile B:\n\t\tA, B = B, A % B\n\treturn A"}
{"task_id": "HumanEval/14", "prompt": "def f(STR):\n\t\"\"\"返回输入字符串中从最短到最长的所有前缀的列表\n例子：f(\"i\") = ['i']\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n", "entry_point": "all_prefixes", "completion": "    prefixes = []\n    for i in range(1, len(STR)+1):\n        prefixes.append(STR[:i])\n    return prefixes"}
{"task_id": "HumanEval/15", "prompt": "def f(N):\n\t\"\"\"返回一个字符串，其中包含从 0 到 N（含）的以空格分隔的数字。\n例子：f(1) = '0 1'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n", "entry_point": "string_sequence", "completion": "def f(N):\n    return ' '.join(str(i) for i in range(N+1))"}
{"task_id": "HumanEval/16", "prompt": "def f(STR):\n\t\"\"\"给定一个字符串，找出它由多少个不同的字符（无论大小写）组成\n例子：f(\"k\") = 1\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n", "entry_point": "count_distinct_characters", "completion": "def f(STR):\n    unique_chars = set(STR.lower())\n    return len(unique_chars)"}
{"task_id": "HumanEval/17", "prompt": "def f(MUS):\n\t\"\"\"该函数的输入是一个以特殊 ASCII 格式表示音符的字符串。您的任务是解析该字符串并返回与每个不持续的节拍数相对应的整数列表。这是一个图例：“o”-整个音符，持续四拍“o|” - 二分音符，持续两拍“.|” - 四分音符，持续一个节拍\n例子：f(\"o\") = [4]\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n", "entry_point": "parse_music", "completion": "def f(MUS):\n    durations = {'o': 4, 'o|': 2, '.|': 1}\n    result = []\n    i = 0\n    while i < len(MUS):\n        if MUS[i:i+2] in durations:\n            result.append(durations[MUS[i:i+2]])\n            i += 2\n        else:\n            result.append(durations[MUS[i]])\n            i += 1\n    return result"}
{"task_id": "HumanEval/18", "prompt": "def f(STR, SUB):\n\t\"\"\"求给定的子字符串在原始字符串中出现了多少次。计算重叠的案例。\n例子：f('z', '') = 2\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n", "entry_point": "how_many_times", "completion": "def f(STR, SUB):\n    count = 0\n    if len(SUB) == 0:\n        return len(STR) + 1\n    for i in range(len(STR)):\n        if STR[i:i + len(SUB)] == SUB:\n            count += 1\n    return count"}
{"task_id": "HumanEval/19", "prompt": "def f(NUMs):\n\t\"\"\"输入是一个以空格分隔的数字字符串，从“零”到“九”。有效选择为“零”、“一”、“二”、“三”、“四”、“五”、“六”、“七”、“八”和“九”。返回数字从小到大排序的字符串\n例子：f(\"one\") = 'one'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "entry_point": "sort_numbers", "completion": "def f(NUMs):\n    num_dict = {\"zero\": \"0\", \"one\": \"1\", \"two\": \"2\", \"three\": \"3\", \"four\": \"4\", \"five\": \"5\", \"six\": \"6\", \"seven\": \"7\", \"eight\": \"8\", \"nine\": \"9\"}\n    num_list = NUMs.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)"}
{"task_id": "HumanEval/20", "prompt": "def f(NUMs):\n\t\"\"\"从提供的数字列表（长度至少为两个）中选择并返回两个最接近的数字，并按顺序返回它们（较小的数字，较大的数字）。\n例子：f([2.376, 5.979, 5.7, 1.555, 4.588]) = (5.7, 5.979)\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n", "entry_point": "find_closest_elements", "completion": "def f(NUMs):\n    NUMs.sort()  # 将数字列表从小到大排序\n    min_diff = float('inf')  # 初始化最小差值为正无穷大\n    result = ()\n    for i in range(len(NUMs) - 1):\n        diff = NUMs[i+1] - NUMs[i]  # 计算相邻两个数字的差值\n        if diff < min_diff:  # 如果当前差值比之前的最小差值还小\n            min_diff = diff  # 更新最小差值\n            result = (NUMs[i], NUMs[i+1])  # 更新结果为当前两个数字\n    return result  # 返回最接近的两个数字"}
{"task_id": "HumanEval/21", "prompt": "def f(NUMs):\n\t\"\"\"给定数字列表（至少有两个元素），对该列表应用线性变换，使得最小的数字将变为 0，最大的数字将变为 1\n例子：f([3.2, 51.8]) = [0.0, 1.0]\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "entry_point": "rescale_to_unit", "completion": "def f(NUMs):\n    min_num = min(NUMs)\n    max_num = max(NUMs)\n    new_nums = [(x - min_num) / (max_num - min_num) for x in NUMs]\n    return new_nums"}
{"task_id": "HumanEval/22", "prompt": "def f(VALs):\n\t\"\"\"仅过滤整数的任何 python 值的给定列表\n例子：f([6, 'b', 3, 5, 'j', 'q']) = [6, 3, 5]\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n", "entry_point": "filter_integers", "completion": "def f(VALs):\n    return [x for x in VALs if isinstance(x, int)]"}
{"task_id": "HumanEval/23", "prompt": "def f(STR):\n\t\"\"\"返回给定字符串的长度\n例子：f(\"m\") = 1\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n", "entry_point": "strlen", "completion": "\treturn len(STR)"}
{"task_id": "HumanEval/24", "prompt": "def f(N):\n\t\"\"\"对于给定的数字N，找到能整除N的最大数，且小于N\n例子：f(8) = 4\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n", "entry_point": "largest_divisor", "completion": "def f(N):\n    for i in range(N-1, 0, -1):\n        if N % i == 0:\n            return i\n    return None"}
{"task_id": "HumanEval/25", "prompt": "def f(N):\n\t\"\"\"按从小到大的顺序返回给定整数的质因数列表。每个因子的列出次数应与其在因式分解中出现的次数相对应。输入数字应等于所有因素的乘积\n例子：f(1) = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n", "entry_point": "factorize", "completion": "\n\t# 初始化一个空列表来存储质因数\n\tprime_factors = []\n\t# 从2开始循环直到N\n\tfor i in range(2, N+1):\n\t\t# 如果i是N的因子\n\t\twhile N % i == 0:\n\t\t\t# 将i添加到质因数列表中\n\t\t\tprime_factors.append(i)\n\t\t\t# 更新N为N除以i的结果\n\t\t\tN = N // i\n\t# 返回质因数列表\n\treturn prime_factors"}
{"task_id": "HumanEval/26", "prompt": "def f(NUMs):\n\t\"\"\"从整数列表中删除所有出现多次的元素。保持元素的顺序与输入中的相同。\n例子：f([1, 1, 6, 6]) = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n", "entry_point": "remove_duplicates", "completion": "def f(NUMs):\n    result = []\n    for num in NUMs:\n        if NUMs.count(num) == 1:\n            result.append(num)\n    return result\n\n# Test the function\nprint(f([1, 1, 6, 6]))  # Output: []"}
{"task_id": "HumanEval/27", "prompt": "def f(STR):\n\t\"\"\"对于给定的字符串，将小写字符翻转为大写，将大写翻转为小写。\n例子：f(\"w\") = 'W'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "entry_point": "flip_case", "completion": "def f(STR):\n    result = \"\"\n    for char in STR:\n        if char.islower():\n            result += char.upper()\n        elif char.isupper():\n            result += char.lower()\n        else:\n            result += char\n    return result"}
{"task_id": "HumanEval/28", "prompt": "def f(STRs):\n\t\"\"\"将字符串列表连接成单个字符串\n例子：f(['c', 'q', 'p']) = 'cqp'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n", "entry_point": "concatenate", "completion": "    return ''.join(STRs)"}
{"task_id": "HumanEval/29", "prompt": "def f(STRs, PRE):\n\t\"\"\"仅过滤以给定前缀开头的字符串输入列表。\n例子：f([], 's') = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n", "entry_point": "filter_by_prefix", "completion": "\tfiltered_list = [s for s in STRs if s.startswith(PRE)]\n\treturn filtered_list"}
{"task_id": "HumanEval/30", "prompt": "def f(L):\n\t\"\"\"仅返回列表中的正数。\n例子：f([2, 0]) = [2]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "entry_point": "get_positive", "completion": "    return [x for x in L if x > 0]"}
{"task_id": "HumanEval/31", "prompt": "def f(N):\n\t\"\"\"如果给定数字是素数，则返回 true，否则返回 false。\n例子：f(7) = True\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "entry_point": "is_prime", "completion": "def f(N):\n    if N < 2:\n        return False\n    for i in range(2, int(N**0.5) + 1):\n        if N % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/32", "prompt": "def f(XS):\n\t\"\"\"XS 是多项式的系数。 f 找到 x 使得 poly(x) = 0。f 只返回零点，即使有很多。此外，f 仅采用具有偶数个系数和最大非零系数的列表 XS，因为它保证了解决方案。\n例子：abs(f([-24, -6]) - -4.0) < 1e-6\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n", "entry_point": "find_zero", "completion": "def f(XS):\n    if len(XS) % 2 != 0 or XS[-1] == 0:\n        return \"Invalid input\"\n\n    roots = []\n    for i in range(len(XS) - 1):\n        if i % 2 == 0:\n            root = -XS[i] / XS[i + 1]\n            roots.append(root)\n\n    return roots\n\n# Example usage\nprint(abs(f([-24, -6])[0] - -4.0) < 1e-6)"}
{"task_id": "HumanEval/33", "prompt": "def f(L):\n\t\"\"\"该函数接受一个列表 L 并返回一个列表 L'，使得 L' 与不能被三整除的索引中的 L 相同，而它在能被三整除的索引处的值等于相应索引的值L，但已排序。\n例子：f([4, 4, 1]) = [4, 4, 1]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n", "entry_point": "sort_third", "completion": "def f(L):\n    L_prime = L.copy()\n    for i in range(len(L)):\n        if i % 3 != 0:\n            L_prime[i] = L[i]\n    L_prime.sort()\n    return L_prime"}
{"task_id": "HumanEval/34", "prompt": "def f(L):\n\t\"\"\"返回列表中已排序的 f 个元素\n例子：f([7, 5, 5, 1, 7, 8, 5, 5, 121]) = [1, 5, 7, 8, 121]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "entry_point": "unique", "completion": "def f(L):\n    return sorted(list(set(L)))"}
{"task_id": "HumanEval/35", "prompt": "def f(L):\n\t\"\"\"返回列表中的最大元素。\n例子：f([4, 1, 6]) = 6\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n", "entry_point": "max_element", "completion": "    return max(L)"}
{"task_id": "HumanEval/36", "prompt": "def f(N):\n\t\"\"\"返回数字 7 在小于 N 且能被 11 或 13 整除的整数中出现的次数。\n例子：f(74) = 0\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n", "entry_point": "fizz_buzz", "completion": "\tcount = 0\n\tfor i in range(1, N):\n\t\tif i % 11 == 0 or i % 13 == 0:\n\t\t\tif '7' in str(i):\n\t\t\t\tcount += 1\n\treturn count"}
{"task_id": "HumanEval/37", "prompt": "def f(L):\n\t\"\"\"该函数采用列表 L 并返回列表 L'，使得 L' 与奇数索引中的 L 相同，而其偶数索引处的值等于 L 的偶数索引的值，但已排序。\n例子：f([1, 1, 6]) = [1, 1, 6]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n", "entry_point": "sort_even", "completion": "def f(L):\n    odd_index = L[1::2]  # 获取奇数索引处的值\n    even_index = sorted(L[::2])  # 获取偶数索引处的值并排序\n    result = [0] * (len(L))  # 创建一个与L相同长度的列表\n    result[1::2] = odd_index  # 将奇数索引处的值赋给结果列表\n    result[::2] = even_index  # 将偶数索引处的排序值赋给结果列表\n    return result  # 返回结果列表\n\nprint(f([1, 1, 6]))  # 测试例子 输出：[1, 1, 6]"}
{"task_id": "HumanEval/38", "prompt": "def f(S):\n\t\"\"\"用作使用encode_circlic函数编码的输入字符串。返回解码后的字符串。\n例子：f(\"/ljlot\") = 'j/ltlo'\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n", "entry_point": "decode_cyclic", "completion": "def f(S):\n    def encode_circular(s):\n        return s[-1] + s[:-1]\n\n    def decode_circular(s):\n        return s[1:] + s[0]\n\n    return decode_circular(S)"}
{"task_id": "HumanEval/39", "prompt": "def f(N):\n\t\"\"\"f 返回第 N 个斐波那契数，并且它也是素数。\n例子：f(11) = 2971215073\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "entry_point": "prime_fib", "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\ndef f(N):\n    a, b = 1, 1\n    count = 2\n    while count < N:\n        a, b = b, a + b\n        count += 1\n    while not is_prime(b):\n        a, b = b, a + b\n    return b"}
{"task_id": "HumanEval/40", "prompt": "def f(L):\n\t\"\"\"f 将整数列表作为输入。如果列表中存在三个不同元素且总和为零，则返回 True，否则返回 FaLse。\n例子：f([3]) = False\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "entry_point": "triples_sum_to_zero", "completion": "def f(L):\n    if len(L) < 3:\n        return False\n    for i in range(len(L)):\n        for j in range(i+1, len(L)):\n            for k in range(j+1, len(L)):\n                if L[i] + L[j] + L[k] == 0:\n                    return True\n    return False"}
{"task_id": "HumanEval/41", "prompt": "def f(N):\n\t\"\"\"想象一条路是一条完美笔直的无限长线。 N 辆汽车从左向右行驶；同时，一组不同的 N 辆汽车从右向左行驶。两辆汽车一开始就相距很远。所有汽车以相同的速度行驶。当一辆从左向右移动的汽车撞上一辆从右向左移动的汽车时，两辆汽车就会相撞。然而，汽车却无限坚固、坚固；结果，它们继续沿着自己的轨迹移动，就好像它们没有发生碰撞一样。该函数输出此类冲突的数量。\n例子：f(0) = 0\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n", "entry_point": "car_race_collision", "completion": "def f(N):\n    return N * (N - 1)  # 每辆从左向右行驶的汽车都会与每辆从右向左行驶的汽车相撞一次，所以总共有 N*(N-1) 次冲突。"}
{"task_id": "HumanEval/42", "prompt": "def f(L):\n\t\"\"\"返回元素加 1 的列表。\n例子：f([3, 7, 3]) = [4, 8, 4]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n", "entry_point": "incr_list", "completion": "result = [x + 1 for x in L]\nreturn result"}
{"task_id": "HumanEval/43", "prompt": "def f(L):\n\t\"\"\"f 将整数列表作为输入。如果列表中有两个不同的元素总和为零，则返回 True，否则返回 FaLse。\n例子：f([3]) = False\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "entry_point": "pairs_sum_to_zero", "completion": "def f(L):\n    \"\"\"This function takes a list of integers as input. If there are two different elements in the list whose sum is zero, it returns True, otherwise it returns False.\n    Example: f([3]) = False\"\"\"\n    for i in range(len(L)):\n        for j in range(i+1, len(L)):\n            if L[i] + L[j] == 0:\n                return True\n    return False"}
{"task_id": "HumanEval/44", "prompt": "def f(X, BAS):\n\t\"\"\"将输入数字 X 的数字底数更改为底数。转换后返回字符串表示形式。基数小于10。\n例子：f(490, 6) = '2134'\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n", "entry_point": "change_base", "completion": "def f(X, BAS):\n    \"\"\"将输入数字 X 的数字底数更改为底数。转换后返回字符串表示形式。基数小于10。\n    例子：f(490, 6) = '2134'\"\"\"\n    result = \"\"\n    while X > 0:\n        remainder = X % BAS\n        result = str(remainder) + result\n        X = X // BAS\n    return result"}
{"task_id": "HumanEval/45", "prompt": "def f(A, H):\n\t\"\"\"给定三角形的边长和高回报面积。\n例子：f(4, 4) = 8.0\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n", "entry_point": "triangle_area", "completion": "\tarea = 0.5 * A * H\n\treturn area"}
{"task_id": "HumanEval/46", "prompt": "def f(N):\n\t\"\"\"Fib4 数列与斐波那契数列类似，定义如下： f(0) -> 0 f(1) -> 0 f(2) -> 2 f(3) -> 0 f(N) - > f(N-1) + f(N-2) + f(N-3) + f(N-4)。请编写一个函数来有效计算 f 数列的第 N 个元素。不要使用递归。\n例子：f(6) = 8\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "entry_point": "fib4", "completion": "def f(N):\n    if N == 0:\n        return 0\n    elif N == 1:\n        return 0\n    elif N == 2:\n        return 2\n    elif N == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for i in range(4, N+1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d\n\n# Test the function\nprint(f(6)) # Output: 8"}
{"task_id": "HumanEval/47", "prompt": "def f(L):\n\t\"\"\"返回列表 L 中的元素 f。\n例子：f([8]) = 8\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "entry_point": "median", "completion": "def f(L):\n    \"\"\"Return the element in list L.\"\"\"\n    return L[0] if len(L) > 0 else None"}
{"task_id": "HumanEval/48", "prompt": "def f(TEX):\n\t\"\"\"检查给定字符串是否是回文\n例子：f(\"i\") = True\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "entry_point": "is_palindrome", "completion": "    return TEX == TEX[::-1]"}
{"task_id": "HumanEval/49", "prompt": "def f(N, P):\n\t\"\"\"返回 2^N 模 P（注意数字）。\n例子：f(4, 8) = 0\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n", "entry_point": "modp", "completion": "def f(N, P):\n    return pow(2, N, P)"}
{"task_id": "HumanEval/50", "prompt": "def f(S):\n\t\"\"\"接受使用encode_Shift函数编码的输入字符串。返回解码后的字符串。\n例子：f(\"p{<~~uf%e?f?x>buv[.nt\") = 'kvkyypanznansmwpqpwio'\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n", "entry_point": "decode_shift", "completion": "def f(S):\n    decoded = \"\"\n    for char in S:\n        decoded += chr(ord(char) - 3)\n    return decoded"}
{"task_id": "HumanEval/51", "prompt": "def f(TEX):\n\t\"\"\"f 是一个函数，它接受字符串并返回不带元音的字符串。\n例子：f(\"g\") = 'g'\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "entry_point": "remove_vowels", "completion": "def f(TEX):\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in TEX:\n        if char not in vowels:\n            result += char\n    return result"}
{"task_id": "HumanEval/52", "prompt": "def f(L, T):\n\t\"\"\"如果列表 L 中的所有数字都低于阈值 T，则返回 True。\n例子：not f([1, 8, 4, 10], 10)\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "entry_point": "below_threshold", "completion": "def f(L, T):\n    for num in L:\n        if num >= T:\n            return False\n    return True\n\n# Example\nprint(not f([1, 8, 4, 10], 10)) # Output: True"}
{"task_id": "HumanEval/53", "prompt": "def f(X, Y):\n\t\"\"\"将两个数字 X 和 Y 相加\n例子：f(3006, 5) = 3011\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "entry_point": "add", "completion": "\treturn X + Y"}
{"task_id": "HumanEval/54", "prompt": "def f(S0, S1):\n\t\"\"\"检查两个单词是否具有相同的字符。\n例子：f('ffz', 'fz') = True\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "entry_point": "same_chars", "completion": "    # 将两个单词转换为集合，以去除重复字符\n    set_S0 = set(S0)\n    set_S1 = set(S1)\n    \n    # 检查两个集合是否相等，如果相等则说明两个单词具有相同的字符\n    if set_S0 == set_S1:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/55", "prompt": "def f(N):\n\t\"\"\"返回第 N 个斐波那契数。\n例子：f(6) = 8\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "entry_point": "fib", "completion": "\tif N <= 0:\n\t\treturn \"N必须是正整数\"\n\telif N == 1:\n\t\treturn 0\n\telif N == 2:\n\t\treturn 1\n\telse:\n\t\ta, b = 0, 1\n\t\tfor _ in range(2, N):\n\t\t\ta, b = b, a + b\n\t\treturn b"}
{"task_id": "HumanEval/56", "prompt": "def f(BRAs):\n\t\"\"\"括号是“<”和“>”组成的字符串。如果每个左括号都有相应的右括号，则返回 True。\n例子：not f(\">\")\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n", "entry_point": "correct_bracketing", "completion": "    stack = []\n    for char in BRAs:\n        if char == \"<\":\n            stack.append(char)\n        elif char == \">\":\n            if not stack:\n                return False\n            else:\n                stack.pop()\n    return not stack"}
{"task_id": "HumanEval/57", "prompt": "def f(L):\n\t\"\"\"如果列表元素正在增加或减少，则返回 True。\n例子：f([4, 4, 1, 1]) = True\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n", "entry_point": "monotonic", "completion": "def f(L):\n    increasing = False\n    decreasing = False\n    for i in range(len(L)-1):\n        if L[i] < L[i+1]:\n            increasing = True\n        elif L[i] > L[i+1]:\n            decreasing = True\n    return increasing and decreasing"}
{"task_id": "HumanEval/58", "prompt": "def f(L1, L2):\n\t\"\"\"返回两个列表的已排序唯一 f 元素。\n例子：f([4, 8, 2, 9], [3, 1]) = []\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "entry_point": "common", "completion": "def f(L1, L2):\n    unique_elements = list(set(L1 + L2))\n    unique_elements.sort()\n    return unique_elements"}
{"task_id": "HumanEval/59", "prompt": "def f(N):\n\t\"\"\"返回 N 的最大质因数。假设 N > 1 并且不是素数。\n例子：f(72216) = 59\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "entry_point": "largest_prime_factor", "completion": "import math\n\ndef f(N):\n    max_prime = 0\n    while N % 2 == 0:\n        max_prime = 2\n        N = N / 2\n    for i in range(3, int(math.sqrt(N)) + 1, 2):\n        while N % i == 0:\n            max_prime = i\n            N = N / i\n    if N > 2:\n        max_prime = N\n    return int(max_prime)"}
{"task_id": "HumanEval/60", "prompt": "def f(N):\n\t\"\"\"f 是对 1 到 N 之间的数字求和的函数。\n例子：f(20) = 210\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "entry_point": "sum_to_n", "completion": "\ttotal = 0\n\tfor i in range(1, N+1):\n\t\ttotal += i\n\treturn total"}
{"task_id": "HumanEval/61", "prompt": "def f(BRAs):\n\t\"\"\"括号是一串“(”和“)”。如果每个左括号都有相应的右括号，则返回 True。\n例子：not f(\")\")\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n", "entry_point": "correct_bracketing", "completion": "    stack = []\n    for char in BRAs:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0"}
{"task_id": "HumanEval/62", "prompt": "def f(XS):\n\t\"\"\"XS 表示多项式的系数。 XS[0] + XS[1] * x + XS[2] * x^2 + .... 以相同的形式返回该多项式的 f。\n例子：f([6, 7, 1]) = [7, 2]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "entry_point": "derivative", "completion": "def f(XS):\n    result = []\n    for i in range(1, len(XS)):\n        result.append(XS[i] * i)\n    return result"}
{"task_id": "HumanEval/63", "prompt": "def f(N):\n\t\"\"\"FibFib 数列与斐波那契数列类似，定义如下： f(0) == 0 f(1) == 0 f(2) == 1 f(N) == f(N-1) + f(N-2) + f(N-3)。请编写一个函数来有效计算 f 数列的第 N 个元素。\n例子：f(4) = 2\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "entry_point": "fibfib", "completion": "def f(N):\n    if N == 0:\n        return 0\n    elif N == 1:\n        return 0\n    elif N == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for i in range(3, N+1):\n            result = a + b + c\n            a, b, c = b, c, result\n        return result\n\n# Test the function\nprint(f(4))  # Output: 2"}
{"task_id": "HumanEval/64", "prompt": "def f(S):\n\t\"\"\"编写一个函数 f，它将表示单词的字符串作为输入，并返回字符串中元音的数量。在这种情况下，元音是“a”、“e”、“i”、“o”、“u”。这里，“y”也是元音，但仅当它位于给定单词的末尾时才有效。\n例子：f(\"dpC\") = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "vowels_count", "completion": "def f(S):\n    vowels = \"aeiou\"\n    count = 0\n    S = S.lower()\n    if S[-1] == 'y':\n        S = S[:-1]\n        for char in S:\n            if char in vowels:\n                count += 1\n    else:\n        for char in S:\n            if char in vowels:\n                count += 1\n    return count"}
{"task_id": "HumanEval/65", "prompt": "def f(X, SHI):\n\t\"\"\"循环移位整数X的数字，将数字按移位右移，并将结果作为字符串返回。如果移位>位数，则返回反转的数字。\n例子：f(8, 7) = '8'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "circular_shift", "completion": "def f(X, SHI):\n    X_str = str(X)\n    if SHI > len(X_str):\n        return X_str[::-1]\n    else:\n        return X_str[-SHI:] + X_str[:-SHI]"}
{"task_id": "HumanEval/66", "prompt": "def f(S):\n\t\"\"\"任务 编写一个函数，将字符串作为输入并返回仅高位字符的 ASCII 代码之和。\n例子：f(\"n\") = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n", "entry_point": "digitSum", "completion": "def f(S):\n    total = 0\n    for char in S:\n        if ord(char) >= 128:  # 判断是否为高位字符\n            total += ord(char)  # 将高位字符的 ASCII 码值加到总和中\n    return total  # 返回总和值\n\n# 测试\nprint(f(\"n\"))  # 输出 0\nprint(f(\"ñ\"))  # 输出 241 (ñ 的 ASCII 码为 241)"}
{"task_id": "HumanEval/67", "prompt": "def f(S, N):\n\t\"\"\"在此任务中，您将获得一个字符串，表示分布在一篮子水果中的许多苹果和橙子，该篮子包含苹果、橙子和芒果水果。给定表示橙子和苹果总数的字符串以及表示篮子中水果总数的整数，返回篮子中芒果水果的数量。\n例子：f('2 apples and 3 oranges', 24) = 19\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n", "entry_point": "fruit_distribution", "completion": "def f(S, N):\n    # 提取字符串中的苹果和橙子数量\n    apple_count = int(S.split(' ')[0])\n    orange_count = int(S.split(' ')[3])\n\n    # 计算篮子中的芒果数量\n    mango_count = N - (apple_count + orange_count)\n\n    return mango_count"}
{"task_id": "HumanEval/68", "prompt": "def f(ARR):\n\t\"\"\"“给定一个表示具有非负整数节点的树分支的数组，您的任务是查找其中一个节点并返回它。馈送节点应该是具有最小偶数值的节点。如果多个节点具有相同的最小偶数，找到偶数值返回具有最小索引的节点。馈送节点应以列表形式返回，[smalest_value, 它的索引]，如果没有偶数值或给定数组为空，则返回[]。\n例子：f([5, 7, 3]) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n", "entry_point": "pluck", "completion": "def f(ARR):\n    even_values = [x for x in ARR if x % 2 == 0]\n    if len(even_values) == 0:\n        return []\n    else:\n        min_even = min(even_values)\n        min_even_index = ARR.index(min_even)\n        return [min_even, min_even_index]"}
{"task_id": "HumanEval/69", "prompt": "def f(LST):\n\t\"\"\"给你一个非空的正整数列表。返回大于零且频率大于或等于该整数本身的值的最大整数。整数的频率是它在列表中出现的次数。如果不存在这样的值，则返回-1。\n例子：f([5]) = -1\"\"\"\n", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "entry_point": "search", "completion": "def f(LST):\n    max_val = -1\n    for num in LST:\n        if num > 0 and LST.count(num) >= num:\n            max_val = max(max_val, num)\n    return max_val"}
{"task_id": "HumanEval/70", "prompt": "def f(LST):\n\t\"\"\"给定整数列表，以奇怪的顺序返回列表。奇怪的排序是从最小值开始，然后是剩余整数中的最大值，然后是最小值，依此类推。\n例子：f([9, 3, 5, 7]) = [3, 9, 5, 7]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "strange_sort_list", "completion": "def f(LST):\n    LST.sort()\n    result = []\n    while len(LST) > 0:\n        result.append(LST.pop(0))\n        if len(LST) > 0:\n            result.append(LST.pop(-1))\n    return result"}
{"task_id": "HumanEval/71", "prompt": "def f(A, B, C):\n\t\"\"\"已知三角形三边的长度。如果三边形成有效三角形，则返回四舍五入到小数点后两位的三角形面积。否则返回 -1 当任意两条边之和大于第三条边时，三条边构成一个有效的三角形。\n例子：f(2, 9, 3) = -1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "entry_point": "triangle_area", "completion": "def f(A, B, C):\n    if A + B > C and A + C > B and B + C > A:\n        s = (A + B + C) / 2\n        area = (s * (s - A) * (s - B) * (s - C)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"task_id": "HumanEval/72", "prompt": "def f(Q, W):\n\t\"\"\"编写一个函数，如果对象 Q 会飞，则返回 True，否则返回 False。如果对象 Q 是平衡的（它是一个回文列表）并且其元素之和小于或等于最大可能权重 W，则对象 Q 将会飞行。\n例子：f([1], 5) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "entry_point": "will_it_fly", "completion": "def f(Q, W):\n    if all(isinstance(x, int) for x in Q):\n        if Q == Q[::-1] and sum(Q) <= W:\n            return True\n        else:\n            return False\n    else:\n        return False"}
{"task_id": "HumanEval/73", "prompt": "def f(ARR):\n\t\"\"\"给定一个整数数组 ARR，找到需要更改以使该数组成为回文的最小元素数。回文数组是前后读取相同的数组。在一次更改中，您可以将一个元素更改为任何其他元素。\n例子：f([3]) = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n", "entry_point": "smallest_change", "completion": "    n = len(ARR)\n    count = 0\n    for i in range(n // 2):\n        if ARR[i] != ARR[n - 1 - i]:\n            count += 1\n    return count"}
{"task_id": "HumanEval/74", "prompt": "def f(LST, LST):\n\t\"\"\"编写一个函数，接受两个字符串列表，并返回列表中所有字符串中的字符总数小于另一个列表的列表。如果两个列表具有相同的字符数，则返回第一个列表。\n例子：f([], ['jnk']) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n", "entry_point": "total_match", "completion": "def f(lst1, lst2):\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n    \n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1\n\n# Example usage\nprint(f([], ['jnk']))  # Output: []"}
{"task_id": "HumanEval/75", "prompt": "def f(A):\n\t\"\"\"编写一个函数，如果给定的数字是 3 个素数的乘积，则返回 true，否则返回 fAlse。已知 (A) 小于 100。\n例子：f(7) = False\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "entry_point": "is_multiply_prime", "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef f(A):\n    count = 0\n    for i in range(2, A):\n        if A % i == 0 and is_prime(i):\n            count += 1\n    if count == 3:\n        return True\n    else:\n        return False\n\n# Example usage\nprint(f(7))  # Output: False"}
{"task_id": "HumanEval/76", "prompt": "def f(X, N):\n\t\"\"\"您的任务是编写一个函数，如果数字 X 是 N 的简单幂，则返回 true，其他情况下返回 false。如果 N**iNt=X，则 X 是 N 的简单幂\n例子：f(2, 2) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_simple_power", "completion": "def f(X, N):\n    if X == 1:\n        return True\n    for i in range(2, int(X**0.5)+1):\n        if X % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/77", "prompt": "def f(A):\n\t\"\"\"编写一个函数，它接受一个整数 A，如果该整数是某个整数的立方，则返回 True。注意：您可以假设输入始终有效。\n例子：f(8) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n", "entry_point": "iscube", "completion": "def f(A):\n    if A < 0:\n        A = -A\n    for i in range(A + 1):\n        if i ** 3 == A:\n            return True\n    return False"}
{"task_id": "HumanEval/78", "prompt": "def f(NUM):\n\t\"\"\"您的任务是编写一个函数，该函数以字符串形式接收十六进制数，并计算素数的十六进制数字的数量（素数或质数是大于 1 的自然数，且不是两个较小自然数的乘积）数字）。十六进制数字为 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F。素数为 2, 3, 5, 7, 11, 13, 17,... 所以你必须确定以下数字中的一个数：2,3,5,7,B（=十进制11），D（=十进制13）。注意：您可能假设输入始终是正确的或空字符串，并且符号 A、B、C、D、E、F 始终为大写。\n例子：f(\"J01\") = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n", "entry_point": "hex_key", "completion": "def f(NUM):\n    num = int(NUM, 16)\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    count = 0\n    for i in range(2, num):\n        if num % i == 0:\n            break\n    else:\n        if num in primes:\n            count += 1\n    return count\n\n# Test the function\nprint(f(\"J01\")) # Output: 0"}
{"task_id": "HumanEval/79", "prompt": "def f(DEC):\n\t\"\"\"您将得到一个十进制形式的数字，您的任务是将其转换为二进制格式。该函数应返回一个字符串，其中每个字符代表一个二进制数。字符串中的每个字符都是“0”或“1”。字符串的开头和结尾处会有几个额外的字符“db”。额外的字符有助于格式。\n例子：f(1) = 'db1db'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "decimal_to_binary", "completion": "def f(DEC):\n    binary = bin(DEC)[2:]\n    return 'db' + binary + 'db'"}
{"task_id": "HumanEval/80", "prompt": "def f(S):\n\t\"\"\"给你一个字符串 S。您的任务是检查字符串是否满意。如果字符串的长度至少为 3 并且每 3 个连续的字母都是不同的，则该字符串是满意的\n例子：f(\"p\") = False\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "entry_point": "is_happy", "completion": "def f(S):\n    if len(S) < 3:\n        return False\n    for i in range(len(S) - 2):\n        if S[i] == S[i+1] or S[i] == S[i+2] or S[i+1] == S[i+2]:\n            return False\n    return True\n\n# Example usage\nprint(f(\"p\"))  # Output: False"}
{"task_id": "HumanEval/81", "prompt": "def f(GRAs):\n\t\"\"\"这是学期的最后一周，老师要给学生打分。老师一直在制定自己的评分算法。唯一的问题是，她丢失了用于评分的代码。她给了你一些学生的 GPA 列表，你必须编写一个函数，可以使用下表输出字母成绩列表：GPA |字母等级 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\n例子：f([3.81]) = ['A']\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "numerical_letter_grade", "completion": "def f(GRAs):\n    letter_grades = []\n    for gpa in GRAs:\n        if gpa >= 4.0:\n            letter_grades.append('A+')\n        elif gpa >= 3.7:\n            letter_grades.append('A')\n        elif gpa >= 3.3:\n            letter_grades.append('A-')\n        elif gpa >= 3.0:\n            letter_grades.append('B+')\n        elif gpa >= 2.7:\n            letter_grades.append('B')\n        elif gpa >= 2.3:\n            letter_grades.append('B-')\n        elif gpa >= 2.0:\n            letter_grades.append('C+')\n        elif gpa >= 1.7:\n            letter_grades.append('C')\n        elif gpa >= 1.3:\n            letter_grades.append('C-')\n        elif gpa >= 1.0:\n            letter_grades.append('D+')\n        elif gpa >= 0.7:\n            letter_grades.append('D')\n        elif gpa >= 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades\n\n# Example usage\nprint(f([3.81]))  # Output: ['A']"}
{"task_id": "HumanEval/82", "prompt": "def f(STR):\n\t\"\"\"编写一个函数，接受一个字符串，如果字符串长度是素数则返回 True，否则返回 False\n例子：f(\"K\") = False\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "entry_point": "prime_length", "completion": "def f(STR):\n    length = len(STR)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/83", "prompt": "def f(N):\n\t\"\"\"给定一个正整数 N，返回以 1 开头或结尾的 N 位正整数的个数。\n例子：f(6) = 180000\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "starts_one_ends", "completion": "def f(N):\n    if N == 1:\n        return 10\n    else:\n        return 9 * 10 ** (N-1)"}
{"task_id": "HumanEval/84", "prompt": "def f(N):\n\t\"\"\"给定一个正整数 N，以二进制形式返回其数字的总和。\n例子：f(120) = '11'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "entry_point": "solve", "completion": "def f(N):\n    binary = bin(N)[2:]  # 将N转换为二进制形式，并去掉前缀'0b'\n    total = 0\n    for digit in binary:\n        total += int(digit)\n    return str(total)  # 将总和转换为字符串形式返回"}
{"task_id": "HumanEval/85", "prompt": "def f(LST):\n\t\"\"\"给定一个非空整数列表 LST。 f 位于奇数索引处的偶数元素..\n例子：f([9, 89]) = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n", "entry_point": "add", "completion": "def f(LST):\n    even_elements = [LST[i] for i in range(1, len(LST), 2) if LST[i] % 2 == 0]\n    return sum(even_elements) if even_elements else 0\n\n# Example usage\nprint(f([9, 89]))  # Output: 0"}
{"task_id": "HumanEval/86", "prompt": "def f(S):\n\t\"\"\"编写一个函数，它接受一个字符串并返回它的有序版本。字符串的有序版本，是一个字符串，其中所有单词（用空格分隔）都被一个新单词替换，其中所有字符根据 aScii 值按升序排列。注意：应保持句子中单词和空格的顺序。\n例子：f(\"p\") = 'p'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "anti_shuffle", "completion": "def f(S):\n    words = S.split()\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(sorted_words)"}
{"task_id": "HumanEval/87", "prompt": "def f(LST, X):\n\t\"\"\"给定一个二维数据，作为嵌套列表，它类似于矩阵，但是与矩阵不同的是，每行可能包含不同数量的列。给定 LST 和整数 X，在列表中查找整数 X，并返回元组列表 [(X1, y1), (X2, y2) ...] 使得每个元组都是一个坐标 - （行，列），从 0 开始。最初按行升序对坐标进行排序。另外，按列按降序对行坐标进行排序。\n例子：f([], 5) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "get_row", "completion": "def f(LST, X):\n    coordinates = []\n    for i in range(len(LST)):\n        for j in range(len(LST[i])):\n            if LST[i][j] == X:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    return coordinates\n\n# Example\nprint(f([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5))  # Output: [(1, 1)]"}
{"task_id": "HumanEval/88", "prompt": "def f(ARR):\n\t\"\"\"给定一个非负整数数组，排序后返回给定数组的副本，如果总和（第一个索引值，最后一个索引值）为奇数，则按升序对给定数组进行排序，或者如果总和（第一个索引值，最后一个索引值）是偶数。注意： * 不要更改给定的数组。\n例子：f([4]) = [4]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n", "entry_point": "sort_array", "completion": "def f(ARR):\n    arr_copy = ARR.copy()\n    if sum(arr_copy) % 2 == 0:\n        return sorted(arr_copy)\n    else:\n        return sorted(arr_copy, reverse=True)"}
{"task_id": "HumanEval/89", "prompt": "def f(S):\n\t\"\"\"创建一个函数 f，它接受一个字符串作为参数，并返回一个包含正在旋转的字母表的字符串。字母表的旋转方式应使字母向下移动二乘以达到两位。\n例子：f(\"hqc\") = 'lug'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "encrypt", "completion": "def f(S):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = alphabet[2:] + alphabet[:2]\n    result = ''\n    for char in S:\n        if char in alphabet:\n            index = alphabet.index(char)\n            result += rotated_alphabet[index]\n        else:\n            result += char\n    return result\n\n# Test the function\nprint(f(\"hqc\"))  # Output: 'lug'"}
{"task_id": "HumanEval/90", "prompt": "def f(LST):\n\t\"\"\"给你一个整数列表。编写一个函数 f() 返回列表中第二小的元素。如果不存在该元素则返回 None。\n例子：f([5, 1]) = 5\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "next_smallest", "completion": "def f(LST):\n    if len(LST) < 2:\n        return None\n    else:\n        sorted_lst = sorted(LST)\n        return sorted_lst[1] if sorted_lst[0] != sorted_lst[1] else None"}
{"task_id": "HumanEval/91", "prompt": "def f(S):\n\t\"\"\"你将得到一串单词，你的任务是计算无聊的数量。无聊是一个以“我”开头的句子。句子由“.”、“?”分隔或者 '！'。\n例子：f(\"I .\") = 1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_bored", "completion": "def f(S):\n    sentences = S.split(\".\")\n    sentences = [s.strip() for s in sentences]\n    count = 0\n    for sentence in sentences:\n        if sentence.startswith(\"I\"):\n            count += 1\n    return count"}
{"task_id": "HumanEval/92", "prompt": "def f(X, Y, Z):\n\t\"\"\"创建一个包含 3 个数字的函数。如果其中一个数字等于其他两个数字之和，并且所有数字均为整数，则返回 true。在任何其他情况下返回 false。\n例子：f(2, 2, 4) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n", "entry_point": "any_int", "completion": "def f(X, Y, Z):\n    if X == Y + Z or Y == X + Z or Z == X + Y:\n        if X.is_integer() and Y.is_integer() and Z.is_integer():\n            return True\n    return False"}
{"task_id": "HumanEval/93", "prompt": "def f(MES):\n\t\"\"\"编写一个接受消息和 fs 的函数，交换所有字母的大小写，将消息中的所有元音替换为英语字母表中该元音前面 2 位的字母。假设只有字母。\n例子：f(\"JRG\") = 'jrg'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "encode", "completion": "def f(MES):\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in MES:\n        if char.isalpha():\n            if char.lower() in vowels:\n                index = (ord(char.lower()) - ord('a')) - 2\n                if index < 0:\n                    index += 26\n                result += chr(ord('a') + index)\n            else:\n                if char.islower():\n                    result += char.upper()\n                else:\n                    result += char.lower()\n        else:\n            result += char\n    return result"}
{"task_id": "HumanEval/94", "prompt": "def f(LST):\n\t\"\"\"给你一个整数列表。您需要找到最大的素值并返回其数字之和。\n例子：f([8995]) = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "entry_point": "skjkasdkd", "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef f(LST):\n    max_prime = 0\n    for num in LST:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    return sum(int(digit) for digit in str(max_prime)) if max_prime > 0 else 0\n\n# Example usage\nprint(f([8995]))  # Output: 0"}
{"task_id": "HumanEval/95", "prompt": "def f(DIC):\n\t\"\"\"给定一个字典，如果所有键都是小写字符串或所有键都是大写字符串，则返回 True，否则返回 False。如果给定的字典为空，该函数应返回 False。\n例子：f({'k': 'rsepwmm'}) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "entry_point": "check_dict_case", "completion": "def f(DIC):\n    if len(DIC) == 0:\n        return False\n    lower = all(key.islower() for key in DIC.keys())\n    upper = all(key.isupper() for key in DIC.keys())\n    return lower or upper"}
{"task_id": "HumanEval/96", "prompt": "def f(N):\n\t\"\"\"实现一个函数，该函数接受一个非负整数并返回一个由前 N 个整数组成的数组，这些整数是素数且小于 N。\n例子：f(13) = [2, 3, 5, 7, 11]\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n", "entry_point": "count_up_to", "completion": "def f(N):\n    primes = []\n    for num in range(2, N):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            primes.append(num)\n    return primes\n\nprint(f(13))  # Output: [2, 3, 5, 7, 11]"}
{"task_id": "HumanEval/97", "prompt": "def f(A, B):\n\t\"\"\"完成接受两个整数并返回它们个位数的乘积的函数。假设输入始终有效。\n例子：f(3, 2) = 6\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n", "entry_point": "multiply", "completion": "def f(A, B):\n    return (A % 10) * (B % 10)"}
{"task_id": "HumanEval/98", "prompt": "def f(S):\n\t\"\"\"给定一个字符串 S，计算偶数索引中大写元音的数量。\n例子：f(\"\") = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "count_upper", "completion": "def f(S):\n    vowels = \"AEIOU\"\n    count = 0\n    for i in range(0, len(S), 2):\n        if S[i].upper() in vowels:\n            count += 1\n    return count\n\n# Example usage\nprint(f(\"hello\"))  # Output: 1 (only 'e' is a vowel at even index)\nprint(f(\"HELLO\"))  # Output: 2 (both 'E' and 'O' are vowels at even index)"}
{"task_id": "HumanEval/99", "prompt": "def f(VAL):\n\t\"\"\"创建一个函数，该函数接受表示数字的值（字符串）并返回最接近的整数。如果该数字与两个整数等距，则将其远离零舍入。示例 >>> f(\"10\") 10 >>> f(\"15.3\") 15 注意：从零舍入意味着如果给定的数字与两个整数等距，则应返回的数字是离零最远。\n例子：f(\".55\") = 1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "entry_point": "closest_integer", "completion": "def f(VAL):\n    num = float(VAL)\n    if num - int(num) >= 0.5:\n        return int(num) + 1\n    elif num - int(num) < -0.5:\n        return int(num) - 1\n    else:\n        return int(num)"}
{"task_id": "HumanEval/100", "prompt": "def f(N):\n\t\"\"\"给定一个正整数 N，你必须堆砌 N 层的石头。第一层有N块石头。下一级的石子数量为： - 如果 N 为奇数，则下一个奇数。 - 如果 N 是偶数，则下一个偶数。返回列表中每个级别的石子数量，其中索引 i 处的元素表示级别 (i+1) 中的石子数量。\n例子：f(1) = [1]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "make_a_pile", "completion": "    stones = [N]\n    for i in range(1, N):\n        if stones[i-1] % 2 == 0:\n            stones.append(stones[i-1] + 1)\n        else:\n            stones.append(stones[i-1] + 2)\n    return stones"}
{"task_id": "HumanEval/101", "prompt": "def f(S):\n\t\"\"\"您将得到一串用逗号或空格分隔的单词。您的任务是将字符串拆分为单词并返回单词数组。\n例子：f(\"b\") = ['b']\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "entry_point": "words_string", "completion": "def f(S):\n    \"\"\"You will receive a string of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n    Example: f(\"b\") = ['b']\"\"\"\n    return S.split(',') if ',' in S else S.split()"}
{"task_id": "HumanEval/102", "prompt": "def f(X, Y):\n\t\"\"\"此函数采用两个正数 X 和 Y，并返回 [X, Y]（含）范围内的最大偶整数。如果没有这样的数字，则该函数应返回 -1。\n例子：f(3, 9) = 8\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "entry_point": "choose_num", "completion": "def f(X, Y):\n    max_even = -1\n    for i in range(X, Y+1):\n        if i % 2 == 0 and i > max_even:\n            max_even = i\n    return max_even"}
{"task_id": "HumanEval/103", "prompt": "def f(N, M):\n\t\"\"\"给定两个正整数 N 和 M，您的任务是计算从 N 到 M（包括 N 和 M）的整数的平均值。将答案四舍五入为最接近的整数并将其转换为二进制。如果 N 大于 M，则返回 -1。\n例子：f(7, 1) = -1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "entry_point": "rounded_avg", "completion": "def f(N, M):\n    if N > M:\n        return -1\n    else:\n        average = round((N + M) / 2)\n        return bin(average)[2:]"}
{"task_id": "HumanEval/104", "prompt": "def f(X):\n\t\"\"\"给定一个正整数 X 的列表。返回没有偶数位的所有元素的排序列表。注意：返回的列表应按升序排序。\n例子：f([132, 98, 29]) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "unique_digits", "completion": "def f(X):\n    odd_elements = [x for x in X if x % 2 != 0]\n    return sorted(odd_elements)"}
{"task_id": "HumanEval/105", "prompt": "def f(ARR):\n\t\"\"\"给定一个整数数组，对 1 到 9 之间的整数进行排序，反转结果数组，然后将每个数字替换为“一”、“二”、“三”、“四”、“五”中对应的名称”、“六”、“七”、“八”、“九”。\n例子：f([2, 0, 52]) = ['Two']\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n", "entry_point": "by_length", "completion": "def f(ARR):\n    num_names = {1: \"一\", 2: \"二\", 3: \"三\", 4: \"四\", 5: \"五\", 6: \"六\", 7: \"七\", 8: \"八\", 9: \"九\"}\n    sorted_arr = sorted([num for num in ARR if 1 <= num <= 9])\n    reversed_arr = [num_names[num] for num in sorted_arr[::-1]]\n    return reversed_arr\n\n# Example usage\nprint(f([2, 0, 52]))  # Output: ['二']"}
{"task_id": "HumanEval/106", "prompt": "def f(N):\n\t\"\"\"实现以 N 作为参数的函数 f，并返回大小为 N 的列表，如果 i 为偶数，则索引 i 处的元素的值为 i 的阶乘，否则为从 1 到 i 的数字之和。 i 从 1 开始。i 的阶乘是从 1 到 i 的数字的乘法 (1 * 2 * ... * i)。\n例子：f(2) = [1, 2]\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "entry_point": "f", "completion": "def f(N):\n    result = []\n    for i in range(1, N+1):\n        if i % 2 == 0:\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            result.append(sum(range(1, i+1)))\n    return result\n\n# Example\nprint(f(2))  # Output: [1, 2]"}
{"task_id": "HumanEval/107", "prompt": "def f(N):\n\t\"\"\"给定一个正整数 N，返回一个元组，该元组具有落在范围 (1, N)（含）内的偶数和奇数整数回文数。\n例子：f(8) = (4, 4)\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "even_odd_palindrome", "completion": "def f(N):\n    even_palindromes = []\n    odd_palindromes = []\n    \n    for i in range(1, N+1):\n        if i % 2 == 0:  # 偶数\n            if str(i) == str(i)[::-1]:  # 判断是否为回文数\n                even_palindromes.append(i)\n        else:  # 奇数\n            if str(i) == str(i)[::-1]:  # 判断是否为回文数\n                odd_palindromes.append(i)\n    \n    return (len(even_palindromes), len(odd_palindromes))  # 返回偶数回文数和奇数回文数的个数的元组\n\n# 测试\nprint(f(8))  # 输出 (4, 4)"}
{"task_id": "HumanEval/108", "prompt": "def f(ARR):\n\t\"\"\"编写一个函数 f，它接受一个整数数组并返回数字总和 > 0 的元素数量。如果数字为负数，则其第一个有符号数字将为负数：例如-123 具有符号数字 -1、2 和 3。\n例子：f([2]) = 1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "count_nums", "completion": "def f(ARR):\n    count = 0\n    for num in ARR:\n        if int(str(num)[0]) != 0 and int(str(num)[0]) != \"-\":\n            count += 1\n    return count"}
{"task_id": "HumanEval/109", "prompt": "def f(ARR):\n\t\"\"\"我们有一个由 N 个整数组成的数组 'ARR' ARR[1], ARR[2], ..., ARR[N]。数组中的数字将随机排序。您的任务是确定是否可以通过对给定数组执行以下操作来获得按非降序排序的数组： 允许您执行任意次右移操作。右移一操作是指将数组中的所有元素向右移动一位。数组的最后一个元素将被移动到数组的起始位置，即第 0 个索引。如果执行上述操作可以获得有序数组，则返回 True，否则返回 False。如果给定数组为空则返回 True。注意：保证给定的列表具有唯一的元素。\n例子：f([]) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "entry_point": "move_one_ball", "completion": "def f(ARR):\n    if len(ARR) == 0:\n        return True\n    else:\n        sorted_arr = sorted(ARR)\n        for i in range(len(ARR)):\n            if ARR == sorted_arr:\n                return True\n            else:\n                ARR = [ARR[-1]] + ARR[:-1]\n        return False\n\n# Example usage\nprint(f([3, 1, 2])) # Output: True\nprint(f([1, 2, 3])) # Output: True\nprint(f([3, 2, 1])) # Output: False"}
{"task_id": "HumanEval/110", "prompt": "def f(LST, LST):\n\t\"\"\"在此问题中，您将实现一个函数，该函数接受两个数字列表，并确定是否可以在它们之间执行 f 元素以使 LST 成为仅包含偶数的列表。 LST 和 LST 之间的 fd 元素数量没有限制。如果可以在LST和LST之间f个元素使得LST的所有元素都为偶数，则返回“YES”。否则，返回“NO”。\n例子：f([6, 8, 5], [7, 5, 1]) = 'NO'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "entry_point": "exchange", "completion": "def f(LST1, LST2):\n    even_count = 0\n    for num in LST1:\n        if num % 2 == 0:\n            even_count += 1\n    for num in LST2:\n        if num % 2 == 0:\n            even_count += 1\n    if even_count == len(LST1) + len(LST2):\n        return 'YES'\n    else:\n        return 'NO'"}
{"task_id": "HumanEval/111", "prompt": "def f(TES):\n\t\"\"\"给定一个表示以空格分隔的小写字母的字符串，返回重复次数最多且包含相应计数的字母的字典。如果多个字母出现相同的情况，则返回所有字母。\n例子：f(\"y\") = {'y': 1}\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n", "entry_point": "histogram", "completion": "def f(TES):\n    count = {}\n    for char in TES:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    max_count = max(count.values())\n    result = {key: value for key, value in count.items() if value == max_count}\n    return result"}
{"task_id": "HumanEval/112", "prompt": "def f(S, C):\n\t\"\"\"任务 给定两个字符串 S 和 C，你必须删除 S 中与 C 中任意字符相等的所有字符，然后检查结果字符串是否为回文。如果一个字符串向后读与向前读相同，则称为回文。您应该返回一个包含结果字符串和 True/FalSe 的元组以进行检查。\n例子：f('i', 'i') = ('', True)\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "entry_point": "reverse_delete", "completion": "def f(S, C):\n    # 删除S中与C中任意字符相等的所有字符\n    result = ''.join([char for char in S if char not in C])\n    \n    # 检查结果字符串是否为回文\n    if result == result[::-1]:\n        return (result, True)\n    else:\n        return (result, False)"}
{"task_id": "HumanEval/113", "prompt": "def f(LST):\n\t\"\"\"给定一个字符串列表，其中每个字符串仅包含数字，返回一个列表。输出的每个元素 i 应该是“输入的字符串 i 中奇数元素的数量”。其中所有 i 应替换为输入的第 i 个字符串中的奇数位数。\n例子：f(['421']) = ['the number of odd elements 1n the str1ng 1 of the 1nput.']\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "odd_count", "completion": "def f(LST):\n    result = []\n    for s in LST:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f'the number of odd elements {count} in the string {s} of the input.')\n    return result"}
{"task_id": "HumanEval/114", "prompt": "def f(NUMs):\n\t\"\"\"给定一个整数数组 NUMs，找到 NUMs 的任何非空子数组的最小和。\n例子：f([6]) = 6\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n", "entry_point": "minSubArraySum", "completion": "def f(NUMs):\n    if len(NUMs) == 0:\n        return 0\n    min_sum = float('inf')\n    current_sum = 0\n    for num in NUMs:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum\n\n# Example usage\nprint(f([6]))  # Output: 6"}
{"task_id": "HumanEval/115", "prompt": "def f(GRI, CAP):\n\t\"\"\"您将获得一个矩形网格的井。每行代表一个井，每行中的每个 1 代表一个单位的水。每口井都有一个相应的桶，可以用来从井中提取水，并且所有桶的容量相同。您的任务是使用水桶清空水井。输出您需要降低铲斗的次数。\n例子：f([[4, 3, 4], [1, 2, 5]], 4) = 5\"\"\"\n", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "entry_point": "max_fill", "completion": "def f(GRI, CAP):\n    total_water = sum([sum(row) for row in GRI])\n    buckets_needed = total_water // CAP\n    if total_water % CAP != 0:\n        buckets_needed += 1\n    return buckets_needed\n\n# Example usage\nprint(f([[4, 3, 4], [1, 2, 5]], 4)) # Output: 5"}
{"task_id": "HumanEval/116", "prompt": "def f(ARR):\n\t\"\"\"在此 Kata 中，您必须根据二进制表示形式中的个数以升序对非负整数数组进行排序。对于相似数量的，根据十进制值排序。它必须像这样实现：\n例子：f([2, 3, 5, 5, 4]) = [2, 4, 3, 5, 5]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "sort_array", "completion": "def f(ARR):\n    # 定义一个函数，用于计算一个数的二进制表示中1的个数\n    def count_ones(num):\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count\n\n    # 对数组进行排序，首先按照二进制表示中1的个数升序排序，然后按照十进制值排序\n    ARR.sort(key=lambda x: (count_ones(x), x))\n    return ARR\n\n# 测试\nprint(f([2, 3, 5, 5, 4]))  # 输出 [2, 4, 3, 5, 5]"}
{"task_id": "HumanEval/117", "prompt": "def f(S, N):\n\t\"\"\"给定一个字符串 S 和一个自然数 N，您的任务是实现一个函数，该函数返回字符串 S 中恰好包含 N 个辅音的所有单词的列表，以便这些单词出现在字符串 S 中。如果字符串 S 为空，则该函数应返回一个空列表。注意：您可以假设输入字符串仅包含字母和空格。\n例子：f('g', 5) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "entry_point": "select_words", "completion": "def f(S, N):\n    vowels = \"aeiouAEIOU\"\n    words = S.split()\n    result = []\n    for word in words:\n        count = 0\n        for char in word:\n            if char in vowels:\n                count += 1\n        if count == N:\n            result.append(word)\n    return result\n\n# Example usage\nprint(f('g', 5))  # Output: []"}
{"task_id": "HumanEval/118", "prompt": "def f(WOR):\n\t\"\"\"你得到了一句话。您的任务是找到单词右侧两个辅音之间最接近的元音（区分大小写）。开头和结尾的元音不计算在内。如果没有找到满足上述条件的元音，则返回空字符串。您可以假设给定的字符串仅包含英文字母。\n例子：f(\"asl\") = ''\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "get_closest_vowel", "completion": "def f(WOR):\n    vowels = \"aeiouAEIOU\"\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    for i in range(1, len(WOR)-1):\n        if WOR[i] in consonants and WOR[i+1] in consonants:\n            for j in range(i+1, len(WOR)-1):\n                if WOR[j] in vowels:\n                    return WOR[j]\n    return ''"}
{"task_id": "HumanEval/119", "prompt": "def f(LST):\n\t\"\"\"您将获得两个字符串的列表，这两个字符串均仅包含左括号“(”或右括号“)”。您的工作是检查是否可以按某种顺序连接两个字符串，以及结果字符串是否良好。当且仅当 S 中的所有括号都是平衡的时，字符串 S 才被认为是好的。\n例子：f((')', ')')) = 'No'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n", "entry_point": "match_parens", "completion": "def f(LST):\n    stack = []\n    for s in LST:\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            else:\n                if len(stack) == 0:\n                    return 'No'\n                else:\n                    stack.pop()\n    if len(stack) == 0:\n        return 'Yes'\n    else:\n        return 'No'"}
{"task_id": "HumanEval/120", "prompt": "def f(ARR, K):\n\t\"\"\"给定一个整数数组 ARR 和一个正整数 K，返回长度为 K 的排序列表，其中 ARR 中有 f K 个数字。\n例子：f([2, 1], 1) = [2]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "entry_point": "maximum", "completion": "def f(ARR, K):\n    return sorted(ARR)[:K]"}
{"task_id": "HumanEval/121", "prompt": "def f(LST):\n\t\"\"\"给定一个非空整数列表，返回位于偶数位置的所有奇数元素的总和。\n例子：f([6, 7]) = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n", "entry_point": "solution", "completion": "def f(LST):\n    \"\"\"Given a non-empty list of integers, return the sum of all odd elements at even positions.\n    Example: f([6, 7]) = 0\"\"\"\n    return sum(LST[i] for i in range(1, len(LST), 2) if LST[i] % 2 != 0)"}
{"task_id": "HumanEval/122", "prompt": "def f(ARR, K):\n\t\"\"\"给定一个非空整数数组 ARR 和一个整数 K，返回 ARR 的前 K 个元素中最多包含两位数的元素之和。\n例子：f([3], 4) = 3\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "add_elements", "completion": "def f(ARR, K):\n    \"\"\"Given a non-empty integer array ARR and an integer K, return the sum of at most two-digit elements in the first K elements of ARR.\n    Example: f([3], 4) = 3\"\"\"\n    return sum([x for x in ARR[:K] if x < 100])"}
{"task_id": "HumanEval/123", "prompt": "def f(N):\n\t\"\"\"给定一个正整数 N，返回一个排序列表，其中包含 collat​​z 序列中的奇数。 Collat​​z 猜想是一个数学猜想，涉及一个定义如下的序列：以任意正整数 N 开始。然后每一项都是从前一项得到的，如下所示：如果前一项是偶数，则下一项是前一项的一半。如果前一项是奇数，则后一项是前一项的3倍加1。猜想是，无论N取什么值，序列总是达到1。 注意：1. Collat​​z(1)是[1]。 2. 返回的列表按升序排序。\n例子：f(8) = [1]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "get_odd_collatz", "completion": "def f(N):\n    result = [N]\n    while N != 1:\n        if N % 2 == 0:\n            N = N // 2\n        else:\n            N = 3 * N + 1\n        result.append(N)\n    return sorted([x for x in result if x % 2 != 0])"}
{"task_id": "HumanEval/124", "prompt": "def f(DAT):\n\t\"\"\"您必须编写一个函数来验证给定的日期字符串，如果日期有效则返回 True，否则返回 False。如果满足以下所有规则，则日期有效： 1. 日期字符串不为空。 2、第1、3、5、7、8、10、12个月的天数不少于1天或大于31天。 4、6、9、11月份的天数不少于1天或大于30天。并且，2 月的天数不得小于 1 或大于 29。 3. 月份不得小于 1 或大于 12。 4. 日期的格式应为：mm-dd-yyyy\n例子：f(\"x\") = False\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n", "entry_point": "valid_date", "completion": "def f(DAT):\n    if len(DAT) != 10:\n        return False\n    else:\n        try:\n            month, day, year = map(int, DAT.split('-'))\n            if month < 1 or month > 12:\n                return False\n            if day < 1 or day > 31:\n                return False\n            if month in [4, 6, 9, 11] and day > 30:\n                return False\n            if month == 2:\n                if year % 4 == 0:\n                    if day > 29:\n                        return False\n                else:\n                    if day > 28:\n                        return False\n            return True\n        except ValueError:\n            return False\n\n# Test cases\nprint(f(\"02-29-2020\"))  # True\nprint(f(\"04-31-2020\"))  # False\nprint(f(\"13-01-2020\"))  # False\nprint(f(\"12-25-2020\"))  # True\nprint(f(\"x\"))  # False"}
{"task_id": "HumanEval/125", "prompt": "def f(TXT):\n\t\"\"\"给定一串单词，返回按空格分割的单词列表，如果文本中不存在空格，则应以逗号 ',' 分割，如果不存在逗号，则应返回字母表中奇数顺序的小写字母的数量, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n例子：f(\"p\") = 1\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n", "entry_point": "split_words", "completion": "def f(TXT):\n    if ' ' in TXT:\n        return TXT.split(' ')\n    elif ',' in TXT:\n        return TXT.split(',')\n    else:\n        return [chr(i) for i in range(97, 123, 2)]"}
{"task_id": "HumanEval/126", "prompt": "def f(LST):\n\t\"\"\"给定一个数字列表，返回它们是否按升序排序。如果列表中有超过 1 个相同数字的重复项，则返回 False。假设没有负数，只有整数。\n例子：f([4]) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n", "entry_point": "is_sorted", "completion": "def f(LST):\n    if len(LST) <= 1:\n        return True\n    for i in range(len(LST) - 1):\n        if LST[i] >= LST[i + 1]:\n            return False\n    return True"}
{"task_id": "HumanEval/127", "prompt": "def f(INT, INT):\n\t\"\"\"给定两个区间，其中每个区间都是一对整数。\n例子：f((4, 3), (3, 6)) = 'NO'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "entry_point": "intersection", "completion": "def f(interval1, interval2):\n    if interval1[0] > interval2[1] or interval2[0] > interval1[1]:\n        return 'NO'\n    else:\n        return 'YES'"}
{"task_id": "HumanEval/128", "prompt": "def f(ARR):\n\t\"\"\"给定一个整数数组 ARR，您需要返回整数的幅值之和乘以数组中每个数字的所有符号的乘积，用 1、-1 或 0 表示。注意：对于空 ARR，返回 None。\n例子：f([5, 2]) = 7\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "prod_signs", "completion": "def f(ARR):\n    if not ARR:\n        return None\n    else:\n        amplitude_sum = sum(abs(num) for num in ARR)\n        sign_product = 1\n        for num in ARR:\n            if num > 0:\n                sign_product *= 1\n            elif num < 0:\n                sign_product *= -1\n            else:\n                sign_product *= 0\n        return amplitude_sum * sign_product\n\n# Example usage\nprint(f([5, 2]))  # Output: 7"}
{"task_id": "HumanEval/129", "prompt": "def f(GRI, K):\n\t\"\"\"给定一个包含 N 行和 N 列 (N >= 2) 的网格和一个正整数 K，网格的每个单元格都包含一个值。 [1, N * N] 范围内的每个整数（含）在网格单元上恰好出现一次。你必须找到网格中长度为 K 的最小路径。您可以从任何单元格开始，在每一步中您可以移动到任何相邻单元格，换句话说，您可以转到与当前单元格共享边缘的单元格。请注意，长度为 K 的路径意味着恰好访问 K 个单元格（不一定是不同的）。你不能脱离电网。如果在对 A 和 B 所经过的单元格上的值进行排序列表（让我们称它们为 lst_A 和 lst_B）之后，lst_A 按字典顺序排列，则路径 A（长度为 K）被认为小于路径 B（长度为 K）小于 lst_B，换句话说，存在一个整数索引 i (1 <= i <= K) 使得 lst_A[i] < lst_B[i] 并且对于任何 j (1 <= j < i) 我们有 lst_A[ j] = lst_B[j]。保证答案是唯一的。返回最小路径经过的单元格上的值的有序列表。\n例子：f([[4, 4], [7, 6]], 5) = [1, 5, 1, 5, 1]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n", "entry_point": "minPath", "completion": "from heapq import heappush, heappop\n\ndef f(GRI, K):\n    N = len(GRI)\n    heap = [(GRI[i][0], i, 0) for i in range(N)]\n    res = []\n    for _ in range(K):\n        val, i, j = heappop(heap)\n        res.append(val)\n        if j + 1 < N:\n            heappush(heap, (GRI[i][j + 1], i, j + 1))\n    return res\n\nprint(f([[4, 4], [7, 6]], 5))"}
{"task_id": "HumanEval/130", "prompt": "def f(N):\n\t\"\"\"每个人都知道斐波那契数列，在过去的几个世纪里数学家们对它进行了深入的研究。然而，人们不知道的是TriboNacci序列。 TriboNacci 序列由递推式定义： f(1) = 3 f(N) = 1 + N / 2（如果 N 为偶数）。 f(N) = f(N - 1) + f(N - 2) + f(N + 1)（如果 N 为奇数）。\n例子：f(2) = [1, 3, 2.0]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "entry_point": "tri", "completion": "def f(N):\n    if N == 1:\n        return [3]\n    elif N == 2:\n        return [1, 3, 2.0]\n    else:\n        tribo = [1, 3]\n        for i in range(2, N):\n            if i % 2 == 0:\n                tribo.append(1 + i / 2)\n            else:\n                tribo.append(tribo[i-1] + tribo[i-2] + tribo[i-3])\n        return tribo\n\n# Example usage\nprint(f(2))  # Output: [1, 3, 2.0]"}
{"task_id": "HumanEval/131", "prompt": "def f(N):\n\t\"\"\"给定正整数 N，返回奇数 f 的乘积。如果所有 f 均为偶数，则返回 0。\n例子：f(7) = 7\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "entry_point": "digits", "completion": "def f(N):\n    product = 1\n    for i in range(1, N+1, 2):\n        product *= i\n    if product % 2 == 0:\n        return 0\n    else:\n        return product"}
{"task_id": "HumanEval/132", "prompt": "def f(STR):\n\t\"\"\"创建一个函数，将仅包含方括号的字符串作为输入。当且仅当存在有效的括号子序列且子序列中至少嵌套了一个括号时，该函数才应返回 True。\n例子：f(\"b\") = False\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "entry_point": "is_nested", "completion": "def f(STR):\n    stack = []\n    for char in STR:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n    return len(stack) != 0\n\n# Test cases\nprint(f(\"[]\"))  # True\nprint(f(\"[[]]\"))  # True\nprint(f(\"[[[]]]\"))  # True\nprint(f(\"[[[]]]]\"))  # False\nprint(f(\"[[[]]][\"))  # False\nprint(f(\"b\"))  # False"}
{"task_id": "HumanEval/133", "prompt": "def f(LST):\n\t\"\"\"您将获得一个数字列表。您需要返回给定列表中数字的平方和，首先将列表中的每个元素四舍五入到上限 int(Ceiling)。\n例子：f([1]) = 1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "sum_squares", "completion": "def f(LST):\n    total = 0\n    for num in LST:\n        total += int(num) ** 2\n    return total\n\n# Example usage\nprint(f([1]))  # Output: 1"}
{"task_id": "HumanEval/134", "prompt": "def f(TXT):\n\t\"\"\"创建一个函数，如果给定字符串的最后一个字符是字母字符且不是单词的一部分，则返回 True，否则返回 False。注意：“单词”是由空格分隔的一组字符。\n例子：f(\"f\") = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "check_if_last_char_is_a_letter", "completion": "def f(TXT):\n    if TXT[-1].isalpha() and (len(TXT) == 1 or not TXT[-2].isalpha()):\n        return True\n    else:\n        return False\n\n# Example\nprint(f(\"f\"))  # Output: True"}
{"task_id": "HumanEval/135", "prompt": "def f(ARR):\n\t\"\"\"创建一个函数，返回不大于或等于紧邻其前面的元素的最大索引。如果不存在这样的元素则返回-1。给定的数组不会包含重复的值。\n例子：f([]) = -1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "entry_point": "can_arrange", "completion": "def f(ARR):\n    max_indexes = []\n    for i in range(len(ARR)):\n        if i == 0:\n            max_indexes.append(-1)\n        else:\n            max_index = -1\n            for j in range(i):\n                if ARR[j] <= ARR[i]:\n                    max_index = j\n            max_indexes.append(max_index)\n    return max_indexes\n\nprint(f([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])) # Output: [-1, -1, 1, 1, 3, 4, 1, 6, 6, 6, 9]"}
{"task_id": "HumanEval/136", "prompt": "def f(LST):\n\t\"\"\"创建一个返回元组 (a, b) 的函数，其中“a”是列表中最大的负整数，“b”是列表中最小的正整数。如果没有负整数或正整数，则将它们返回为 None。\n例子：f([2]) = (None, 2)\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "entry_point": "largest_smallest_integers", "completion": "def f(LST):\n    max_neg = None\n    min_pos = None\n    for num in LST:\n        if num < 0 and (max_neg is None or num > max_neg):\n            max_neg = num\n        elif num > 0 and (min_pos is None or num < min_pos):\n            min_pos = num\n    return (max_neg, min_pos)"}
{"task_id": "HumanEval/137", "prompt": "def f(A, B):\n\t\"\"\"创建一个函数，该函数接受表示实数的整数、浮点数或字符串，并返回给定变量类型中较大的变量。如果值相等则返回 None。注意：如果实数表示为字符串，则浮点数可能为 。或者 ，\n例子：f(4, 7) = 7\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "compare_one", "completion": "def f(A, B):\n    if type(A) in [int, float] and type(B) in [int, float]:\n        if A > B:\n            return A\n        elif B > A:\n            return B\n        else:\n            return None\n    elif type(A) == str and type(B) == str:\n        A = A.replace(',', '.')\n        B = B.replace(',', '.')\n        A = float(A)\n        B = float(B)\n        if A > B:\n            return A\n        elif B > A:\n            return B\n        else:\n            return None\n    else:\n        return \"Invalid input types\""}
{"task_id": "HumanEval/138", "prompt": "def f(N):\n\t\"\"\"评估给定数字 N 是否可以写成恰好 4 个正偶数的和\n例子：f(568) = True\"\"\"\n", "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n", "entry_point": "is_equal_to_sum_even", "completion": "def f(N):\n    if N % 2 != 0:\n        return False\n    count = 0\n    while N % 2 == 0:\n        N = N // 2\n        count += 1\n    if count % 2 != 0:\n        return False\n    return True"}
{"task_id": "HumanEval/139", "prompt": "def f(N):\n\t\"\"\"巴西阶乘定义为： braziliaN_factorial(N) = N! * (N-1)! * (N-2)! * ... * 1！其中 N > 0\n例子：f(2) = 2\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "entry_point": "special_factorial", "completion": "def f(N):\n    result = 1\n    for i in range(1, N+1):\n        factorial = 1\n        for j in range(1, i+1):\n            factorial *= j\n        result *= factorial\n    return result\n\n# Example\nprint(f(2)) # Output: 2"}
{"task_id": "HumanEval/140", "prompt": "def f(TEX):\n\t\"\"\"给定一个字符串文本，将其中的所有空格替换为下划线，如果字符串有超过 2 个连续空格，则将所有连续空格替换为 - f(\"\n例子：f(\"tDl\") = 'tDl'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n", "entry_point": "fix_spaces", "completion": "def f(TEX):\n    return TEX.replace(\" \", \"_\").replace(\"__\", \"-\")"}
{"task_id": "HumanEval/141", "prompt": "def f(FIL):\n\t\"\"\"创建一个函数，该函数接受表示文件名的字符串，如果文件名有效则返回“Yes”，否则返回“No”。当且仅当满足以下所有条件时，文件名才被视为有效： - 文件名中的数字不得超过三位（“0”-“9”）。 - 文件名恰好包含一个点“.” - 点之前的子字符串不应为空，并且以拉丁字母中的字母开头（'a'-'z' 和 'A'-'Z'）。 - 点后面的子字符串应该是以下之一：['txt', 'exe', 'dll']\n例子：f(\".tt.txt\") = 'No'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n", "entry_point": "file_name_check", "completion": "def f(FIL):\n    if FIL.count('.') != 1:\n        return 'No'\n    else:\n        filename, extension = FIL.split('.')\n        if len(extension) > 3 or not extension.isalpha():\n            return 'No'\n        if filename == '' or not filename[0].isalpha():\n            return 'No'\n        return 'Yes' if extension in ['txt', 'exe', 'dll'] else 'No'"}
{"task_id": "HumanEval/142", "prompt": "def f(LST):\n\t\"\"\"\" 此函数将采用整数列表。对于列表中的所有条目，如果其索引是 3 的倍数，则该函数将对整数条目进行平方；如果其索引是 4 的倍数且不是倍数​​，则该函数将对整数条目进行立方3. 该函数不会更改列表中索引不是 3 或 4 的倍数的条目。然后该函数应返回所有条目的总和。\n例子：f([2]) = 4\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n", "entry_point": "sum_squares", "completion": "def f(LST):\n    total = 0\n    for i in range(len(LST)):\n        if i % 3 == 0:\n            LST[i] = LST[i] ** 2\n        elif i % 4 == 0:\n            LST[i] = LST[i] ** 3\n        total += LST[i]\n    return total\n\n# Example\nprint(f([2]))  # Output: 4"}
{"task_id": "HumanEval/143", "prompt": "def f(SEN):\n\t\"\"\"给你一个代表句子的字符串，该句子包含一些用空格分隔的单词，你必须返回一个字符串，其中包含原始句子中的单词，其长度为素数，新字符串中单词的顺序应该和原来的一样。\n例子：f(\"t o \") = ''\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "entry_point": "words_in_sentence", "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef f(SEN):\n    words = SEN.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"task_id": "HumanEval/144", "prompt": "def f(X, N):\n\t\"\"\"您的任务是实现一个函数来计算表达式 X * N。如果 X * N 计算结果为整数，则该函数返回 True，否则返回 False。 X 和 N 都是分数的字符串表示形式，并具有以下格式：<分子>/<分母>，其中分子和分母都是正整数。您可以假设 X 和 N 是有效分数，并且分母不为零。\n例子：f('24/2', '61/2') = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "entry_point": "simplify", "completion": "def f(X, N):\n    x_num, x_den = map(int, X.split('/'))\n    n_num, n_den = map(int, N.split('/'))\n    result = x_num * n_num / (x_den * n_den)\n    return result.is_integer()"}
{"task_id": "HumanEval/145", "prompt": "def f(NUMs):\n\t\"\"\"编写一个函数，根据数字之和对给定的整数列表进行升序排序。注：如果有多个项的数字之和相似，则按照它们在原列表中的索引进行排序。\n例子：f([3, 9, 2, -9, -13]) = [-9, 2, -13, 3, 9]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "order_by_points", "completion": "def f(NUMs):\n    return sorted(NUMs, key=lambda x: (sum(int(digit) for digit in str(x)), NUMs.index(x)))"}
{"task_id": "HumanEval/146", "prompt": "def f(NUMs):\n\t\"\"\"编写一个函数，以数字数组作为输入，并返回数组中大于 10 且数字的第一个和最后一个数字均为奇数 (1、3、5、7、9) 的元素数量。\n例子：f([6]) = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "entry_point": "specialFilter", "completion": "def f(NUMs):\n    count = 0\n    for num in NUMs:\n        if num > 10 and num % 2 != 0 and str(num)[0] in ['1', '3', '5', '7', '9'] and str(num)[-1] in ['1', '3', '5', '7', '9']:\n            count += 1\n    return count"}
{"task_id": "HumanEval/147", "prompt": "def f(N):\n\t\"\"\"给定一个正整数 N。您必须创建一个长度为 N 的整数数组 a。对于每个 i (1 ≤ i ≤ N)，a[i] = i * i - i + 1 的值。返回 a 的三元组 (a[i], a[j], a[k]) 的数量其中 i < j < k，并且 a[i] + a[j] + a[k] 是 3 的倍数。\n例子：f(2) = 0\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "entry_point": "get_max_triples", "completion": "def f(N):\n    a = [i * i - i + 1 for i in range(1, N+1)]\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n\n# Example usage\nprint(f(2)) # Output: 0"}
{"task_id": "HumanEval/148", "prompt": "def f(PLA, PLA):\n\t\"\"\"我们的太阳系中有八颗行星：离太阳最近的是水星，其次是金星，然后是地球、火星、木星、土星、天王星、海王星。编写一个函数，将两个行星名称作为字符串PLA 和PLA。该函数应返回一个元组，其中包含轨道位于PLA 轨道和PLA 轨道之间的所有行星，并按与太阳的距离排序。如果PLA 或PLA 不是正确的行星名称，该函数应返回一个空元组。\n例子：f('WxA', 'JRQl') = ()\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "entry_point": "bf", "completion": "def f(PLA1, PLA2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if PLA1 not in planets or PLA2 not in planets:\n        return ()\n    else:\n        index1 = planets.index(PLA1)\n        index2 = planets.index(PLA2)\n        start = min(index1, index2)\n        end = max(index1, index2)\n        result = planets[start+1:end]\n        return tuple(result)"}
{"task_id": "HumanEval/149", "prompt": "def f(LST):\n\t\"\"\"编写一个函数，接受字符串列表作为参数，删除其中奇数长度的字符串，并按排序顺序返回结果列表，该列表始终是字符串列表，而不是数字数组，并且它可能包含重复项。列表的顺序应按每个单词的长度升序，并且您应返回按该规则排序的列表。如果两个单词的长度相同，则按字母顺序对列表进行排序。该函数应返回按排序顺序的字符串列表。您可以假设所有单词都具有相同的长度。\n例子：f(['k', 'y', 'x', 'r']) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n", "entry_point": "sorted_list_sum", "completion": "def f(LST):\n    # 删除奇数长度的字符串\n    LST = [word for word in LST if len(word) % 2 == 0]\n    # 按长度和字母顺序排序\n    LST.sort(key=lambda x: (len(x), x))\n    return LST\n\n# 测试\nprint(f(['k', 'y', 'x', 'r']))  # 输出: []"}
{"task_id": "HumanEval/150", "prompt": "def f(N, X, Y):\n\t\"\"\"一个简单的程序，如果 N 是素数，则应返回 X 的值，否则应返回 Y 的值。\n例子：f(2, 6, 3) = 6\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "entry_point": "x_or_y", "completion": "def f(N, X, Y):\n    \"\"\"A simple program that should return the value of X if N is prime, otherwise it should return the value of Y.\n    Example: f(2, 6, 3) = 6\"\"\"\n    if N < 2:\n        return Y\n    for i in range(2, int(N**0.5) + 1):\n        if N % i == 0:\n            return Y\n    return X"}
{"task_id": "HumanEval/151", "prompt": "def f(LST):\n\t\"\"\"给定一个数字列表，返回列表中奇数数字的平方和。忽略负数或非整数。\n例子：f([3, 2]) = 9\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "entry_point": "double_the_difference", "completion": "def f(LST):\n    \"\"\"Given a list of numbers, return the sum of the squares of the odd numbers in the list. Ignore negative numbers or non-integers.\n    Example: f([3, 2]) = 9\"\"\"\n    return sum(x**2 for x in LST if x % 2 != 0 and x > 0 and isinstance(x, int))"}
{"task_id": "HumanEval/152", "prompt": "def f(GAM, GUEs):\n\t\"\"\"我想我们都记得当某些期待已久的事件的结果终于得知时的感觉。那一刻的感受和想法绝对值得记录和比较。您的任务是确定一个人是否正确猜测了多场比赛的结果。您将获得两个长度相等的得分和猜测数组，其中每个索引都显示一个匹配项。返回一个相同长度的数组，表示每个猜测的偏差有多大。如果他们猜对了，该值为 0，如果没有，该值为猜测与分数之间的绝对差。\n例子：f([5, 1, 5], [3, 2, 0]) = [2, 1, 5]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "compare", "completion": "def f(GAM, GUEs):\n    deviations = []\n    for i in range(len(GAM)):\n        deviation = abs(GAM[i] - GUEs[i])\n        deviations.append(deviation)\n    return deviations"}
{"task_id": "HumanEval/153", "prompt": "def f(CLA, EXTs):\n\t\"\"\"您将获得一个类的名称（一个字符串）和一个扩展列表。扩展用于将附加类加载到该类中。扩展的强度如下：令 CAP 为扩展名称中大写字母的数量，令 SM 为扩展名称中小写字母的数量，强度由分数 CAP - SM 给出。您应该找到最强的扩展并返回以下格式的字符串：ClassName.StrongestExtensionName。如果有两个或多个具有相同强度的扩展，您应该选择列表中第一个扩展。\n例子：f('~', ['MxeOK', '920']) = '~.MxeOK'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "entry_point": "Strongest_Extension", "completion": "def f(CLA, EXTs):\n    max_strength = float('-inf')\n    strongest_extension = \"\"\n    \n    for ext in EXTs:\n        cap_count = sum(1 for c in ext if c.isupper())\n        sm_count = sum(1 for c in ext if c.islower())\n        strength = cap_count - sm_count\n        \n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = ext\n    \n    return f\"{CLA}.{strongest_extension}\" if strongest_extension else \"\""}
{"task_id": "HumanEval/154", "prompt": "def f(A, B):\n\t\"\"\"给你 2 个单词。如果第二个单词或其任何旋转是第一个单词中的子字符串，则需要返回 True\n例子：f('apj', '') = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "entry_point": "cycpattern_check", "completion": "def f(A, B):\n    if not B:\n        return True\n    if len(B) > len(A):\n        return False\n    double_A = A + A\n    return B in double_A"}
{"task_id": "HumanEval/155", "prompt": "def f(NUM):\n\t\"\"\"给定一个整数。返回分别具有偶数和奇数位数的元组。\n例子：f(2) = (1, 0)\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "even_odd_count", "completion": "def f(NUM):\n    even_count = 0\n    odd_count = 0\n    num_str = str(NUM)\n    for i in range(len(num_str)):\n        if i % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/156", "prompt": "def f(NUM):\n\t\"\"\"给定一个正整数，获取其等效的罗马数字字符串，并以小写形式返回。限制：1 <= num <= 1000\n例子：f(50) = 'l'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "int_to_mini_roman", "completion": "def f(NUM):\n    if NUM < 1 or NUM > 1000:\n        return \"Number out of range\"\n    \n    roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l', 90: 'xc',\n        100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    result = ''\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        while NUM >= value:\n            result += roman_numerals[value]\n            NUM -= value\n    \n    return result.lower()"}
{"task_id": "HumanEval/157", "prompt": "def f(A, B, C):\n\t\"\"\"已知三角形三边的长度。如果三边形成直角三角形，则返回 True，否则返回 FAlse。直角三角形是一个角为直角或 90 度的三角形。\n例子：f(3, 2, 5) = False\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "entry_point": "right_angle_triangle", "completion": "def f(A, B, C):\n    sides = [A, B, C]\n    sides.sort()\n    if sides[0]**2 + sides[1]**2 == sides[2]**2:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/158", "prompt": "def f(WORs):\n\t\"\"\"编写一个接受字符串列表的函数。该列表包含不同的单词。返回具有最大数量的唯一字符的单词。如果多个字符串具有最大数量的唯一字符，则返回按字典顺序排在第一位的字符。\n例子：f(['e']) = 'e'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n", "entry_point": "find_max", "completion": "def f(WORs):\n    max_unique_chars = 0\n    max_unique_word = ''\n    \n    for word in WORs:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique_chars:\n            max_unique_chars = unique_chars\n            max_unique_word = word\n        elif unique_chars == max_unique_chars:\n            max_unique_word = min(max_unique_word, word)\n    \n    return max_unique_word"}
{"task_id": "HumanEval/159", "prompt": "def f(NUM, NEE, REM):\n\t\"\"\"你是一只饥饿的兔子，你已经吃了一定数量的胡萝卜，但现在你需要吃更多的胡萝卜来完成一天的膳食。你应该返回一个数组[饭后总的芬胡萝卜数，饭后剩下的胡萝卜数]如果剩余的胡萝卜不够，你会吃掉所有剩余的胡萝卜，但仍然会饿。\n例子：f(8, 1, 9) = [9, 8]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n", "entry_point": "eat", "completion": "def f(NUM, NEE, REM):\n    total_carrots = NUM + NEE\n    if total_carrots <= REM:\n        return [total_carrots, 0]\n    else:\n        return [REM, total_carrots - REM]"}
{"task_id": "HumanEval/160", "prompt": "def f(OPE, OPE):\n\t\"\"\"给定两个列表运算符和操作数。第一个列表具有基本代数运算，第二个列表是整数列表。使用两个给定的列表构建代数表达式并返回该表达式的计算结果。基本代数运算： 加法 (+) 减法 (-) 乘法 (*) 整除 (//) 求幂 (**)\n例子：f(['-', '+'], [8, 4, 3]) = 7\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "do_algebra", "completion": "def f(operators, operands):\n    expression = str(operands[0])\n    for i in range(1, len(operands)):\n        expression += \" \" + operators[i-1] + \" \" + str(operands[i])\n    return eval(expression)\n\n# Example usage\nprint(f(['-', '+'], [8, 4, 3])) # Output: 7"}
{"task_id": "HumanEval/161", "prompt": "def f(S):\n\t\"\"\"给你一个字符串 S。如果 S[i] 是一个字母，则将其大小写从小写颠倒到大写，反之亦然，否则保持原样。如果字符串不包含字母，则反转字符串。该函数应该返回结果字符串。\n例子：f(\"7_%\") = '%_7'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "entry_point": "solve", "completion": "def f(S):\n    if not any(char.isalpha() for char in S):\n        return S[::-1]\n    else:\n        return ''.join(char.lower() if char.isupper() else char.upper() for char in S)"}
{"task_id": "HumanEval/162", "prompt": "def f(TEX):\n\t\"\"\"给定一个字符串“TEX”，返回其 md5 哈希等效字符串。如果“TEX”是空字符串，则返回 None。\n例子：f(\"v\") = '9e3669d19b675bd57058fd4664205d2a'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "string_to_md5", "completion": "import hashlib\n\ndef f(TEX):\n    if TEX:\n        return hashlib.md5(TEX.encode()).hexdigest()\n    else:\n        return None"}
{"task_id": "HumanEval/163", "prompt": "def f(A, B):\n\t\"\"\"给定两个正整数 A 和 B，按升序返回 A 和 B 之间的偶数位。\n例子：f(5, 5) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "generate_integers", "completion": "def f(A, B):\n    result = []\n    for i in range(A+1, B):\n        if i % 2 == 0:\n            result.append(i)\n    return result"}
