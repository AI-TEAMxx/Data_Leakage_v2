{"task_id": "HumanEval/0", "prompt": "def f(NUMs, THR):\n\t\"\"\"Vérifiez si dans la liste de nombres donnée, deux nombres sont plus proches l'un de l'autre que le seuil donné.\\Exemple:f([1.81, 6.92, 8.55, 9.5, 3.57], 5.9) = True\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n", "entry_point": "has_close_elements", "completion": "    for i in range(len(NUMs)):\n        for j in range(i+1, len(NUMs)):\n            if abs(NUMs[i] - NUMs[j]) < THR:\n                return True\n    return False"}
{"task_id": "HumanEval/1", "prompt": "def f(PAR):\n\t\"\"\"L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de séparer ces groupes en chaînes distinctes et de renvoyer la liste de ceux-ci. Les groupes séparés sont équilibrés (chaque accolade ouverte est correctement fermée) et ne sont pas imbriquées les unes dans les autres. Ignorez les espaces dans la chaîne d'entrée.\\Exemple:f(\"()()()\") = ['()', '()', '()']\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n", "entry_point": "separate_paren_groups", "completion": "def f(PAR):\n    result = []\n    count = 0\n    start = 0\n    for i in range(len(PAR)):\n        if PAR[i] == '(':\n            count += 1\n        elif PAR[i] == ')':\n            count -= 1\n            if count == 0:\n                result.append(PAR[start:i+1])\n                start = i + 1\n    return result\n\n# Exemple d'utilisation\nprint(f(\"()()()\")) # ['()', '()', '()']"}
{"task_id": "HumanEval/2", "prompt": "def f(NUM):\n\t\"\"\"Étant donné un nombre à virgule flottante positif, il peut être décomposé en une partie entière (le plus grand entier inférieur au nombre donné) et en décimales (la partie restante est toujours inférieure à 1). Renvoie la partie décimale du nombre.\\Exemple:f(3.2) = 0.2\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n", "entry_point": "truncate_number", "completion": "    return NUM - int(NUM)"}
{"task_id": "HumanEval/3", "prompt": "def f(OPEs):\n\t\"\"\"Vous recevez une liste des opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde nul. Votre tâche consiste à détecter si, à un moment donné, le solde du compte tombe en dessous de zéro, et à ce stade, la fonction doit renvoyer True. Sinon, il devrait renvoyer False.\\Exemple:f([2, 3, -8, 2, 3]) = True\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n", "entry_point": "below_zero", "completion": "    solde = 0\n    for op in OPEs:\n        solde += op\n        if solde < 0:\n            return True\n    return False\n\n# Exemple d'utilisation\nprint(f([2, 3, -8, 2, 3])) # True"}
{"task_id": "HumanEval/4", "prompt": "def f(NUMs):\n\t\"\"\"Pour une liste donnée de nombres d’entrée, calculez l’écart moyen absolu autour de la moyenne de cet ensemble de données. L'écart absolu moyen est la différence absolue moyenne entre chaque élément et un point central (moyenne dans ce cas) : MAD = moyenne | x - x_moyenne |\\Exemple:abs(f([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n", "entry_point": "mean_absolute_deviation", "completion": "    moyenne = sum(NUMs) / len(NUMs)\n    MAD = sum(abs(x - moyenne) for x in NUMs) / len(NUMs)\n    return MAD"}
{"task_id": "HumanEval/5", "prompt": "def f(NUMs, DEL):\n\t\"\"\"Insérer un nombre « délimiteur » entre tous les deux éléments consécutifs de la liste d'entrée « numéros »\\Exemple:f([], 6) = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n", "entry_point": "intersperse", "completion": "    result = []\n    for i in range(len(NUMs)):\n        result.append(NUMs[i])\n        if i < len(NUMs) - 1:\n            result.append(DEL)\n    return result"}
{"task_id": "HumanEval/6", "prompt": "def f(PAR):\n\t\"\"\"L'entrée de cette fonction est une chaîne représentée par plusieurs groupes de parenthèses imbriquées séparées par des espaces. Pour chacun des groupes, affichez le niveau d'imbrication de parenthèses le plus profond. Par exemple. (()()) a au maximum deux niveaux d'imbrication tandis que ((())) en a trois.\\Exemple:f(\"\") = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n", "entry_point": "parse_nested_parens", "completion": "def f(PAR):\n    levels = []\n    current_level = 0\n    for char in PAR:\n        if char == '(':\n            current_level += 1\n            levels.append(current_level)\n        elif char == ')':\n            current_level -= 1\n    return levels\n\n# Exemple d'utilisation\nprint(f(\"(()())\")) # Output: [1, 2, 1, 2, 1]\nprint(f(\"((()))\")) # Output: [1, 2, 3, 2, 1]"}
{"task_id": "HumanEval/7", "prompt": "def f(STRs, SUB):\n\t\"\"\"Filtrer une liste d'entrée de chaînes uniquement pour celles qui contiennent une sous-chaîne donnée\\Exemple:f([], 'y') = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n", "entry_point": "filter_by_substring", "completion": "\tfiltered_list = [s for s in STRs if SUB in s]\n\treturn filtered_list"}
{"task_id": "HumanEval/8", "prompt": "def f(NUMs):\n\t\"\"\"Pour une liste d'entiers donnée, renvoie un tuple composé d'une somme et d'un produit de tous les entiers d'une liste. La somme vide doit être égale à 0 et le produit vide doit être égal à 1.\\Exemple:f([9]) = (9, 9)\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n", "entry_point": "sum_product", "completion": "    sum = 0\n    product = 1\n    \n    for num in NUMs:\n        sum += num\n        product *= num\n        \n    return (sum, product)"}
{"task_id": "HumanEval/9", "prompt": "def f(NUMs):\n\t\"\"\"À partir d'une liste d'entiers donnée, générez une liste d'éléments maximum glissants trouvés jusqu'à un moment donné dans la séquence.\\Exemple:f([1, 6, 7, 2]) = [1, 6, 7, 7]\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n", "entry_point": "rolling_max", "completion": "    result = []\n    max_num = float('-inf')\n    \n    for num in NUMs:\n        max_num = max(max_num, num)\n        result.append(max_num)\n    \n    return result"}
{"task_id": "HumanEval/10", "prompt": "def f(STR):\n\t\"\"\"Trouvez le palindrome le plus court qui commence par une chaîne fournie. L'idée de l'algorithme est simple : - Trouvez le suffixe le plus long de la chaîne fournie qui est un palindrome. - Ajouter à la fin de la chaîne l'inverse d'un préfixe de chaîne qui précède le suffixe palindromique.\\Exemple:f(\"o\") = 'o'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n", "entry_point": "make_palindrome", "completion": "    for i in range(len(STR)):\n        if STR[:i+1] == STR[:i+1][::-1]:\n            return STR + STR[:i][::-1]\n    return STR"}
{"task_id": "HumanEval/11", "prompt": "def f(A, B):\n\t\"\"\"L'entrée est constituée de deux chAînes A et B composées uniquement de 1 et de 0. Effectuez un XOR BinAire sur ces entrées et renvoyez le résultAt égAlement sous forme de chAîne.\\Exemple:f('9', '6') = '1'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n", "entry_point": "string_xor", "completion": "def f(A, B):\n    result = \"\"\n    for i in range(len(A)):\n        if A[i] == B[i]:\n            result += '0'\n        else:\n            result += '1'\n    return result\n\n# Exemple d'utilisation\nprint(f('9', '6')) # Résultat attendu : '1'"}
{"task_id": "HumanEval/12", "prompt": "def f(STRs):\n\t\"\"\"Hors de la liste des chaînes, renvoie celle f. Renvoie le premier en cas de plusieurs chaînes de même longueur. Renvoie Aucun si la liste d'entrée est vide.\\Exemple:f(['i', 'u', 'r']) = 'i'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n", "entry_point": "longest", "completion": "    if len(STRs) == 0:\n        return None\n    else:\n        return min(STRs, key=len)"}
{"task_id": "HumanEval/13", "prompt": "def f(A, B):\n\t\"\"\"Renvoie le plus grAnd diviseur commun de deux entiers A et B\\Exemple:f(1, 6) = 1\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n", "entry_point": "greatest_common_divisor", "completion": "    while B != 0:\n        A, B = B, A % B\n    return A"}
{"task_id": "HumanEval/14", "prompt": "def f(STR):\n\t\"\"\"Renvoie la liste de tous les préfixes du plus court au plus long de la chaîne d'entrée\\Exemple:f(\"i\") = ['i']\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n", "entry_point": "all_prefixes", "completion": "    prefixes = []\n    for i in range(1, len(STR)+1):\n        prefixes.append(STR[:i])\n    return prefixes\n\n# Exemple d'utilisation\nprint(f(\"i\")) # ['i']"}
{"task_id": "HumanEval/15", "prompt": "def f(N):\n\t\"\"\"ReNvoie uNe chaîNe coNteNaNt des Nombres délimités par des espaces allaNt de 0 à N iNclus.\\Exemple:f(1) = '0 1'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n", "entry_point": "string_sequence", "completion": "    return ' '.join(str(i) for i in range(N+1))"}
{"task_id": "HumanEval/16", "prompt": "def f(STR):\n\t\"\"\"Étant donné une chaîne, découvrez de combien de caractères distincts (quelle que soit la casse) se compose-t-elle\\Exemple:f(\"k\") = 1\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n", "entry_point": "count_distinct_characters", "completion": "    # Convertir la chaîne en minuscules pour ignorer la casse\n    STR = STR.lower()\n    \n    # Utiliser un ensemble pour stocker les caractères uniques\n    unique_chars = set()\n    \n    # Parcourir chaque caractère de la chaîne\n    for char in STR:\n        # Ajouter le caractère à l'ensemble\n        unique_chars.add(char)\n    \n    # Retourner le nombre de caractères uniques\n    return len(unique_chars)"}
{"task_id": "HumanEval/17", "prompt": "def f(MUS):\n\t\"\"\"L'entrée de cette fonction est une chaîne représentant des notes de musique dans un format ASCII spécial. Votre tâche consiste à analyser cette chaîne et à renvoyer une liste d'entiers correspondant au nombre de battements que chacun ne dure pas. Voici une légende : 'o' - note entière, dure quatre temps 'o|' - blanche, dure deux temps '.|' - noire, dure un temps\\Exemple:f(\"o\") = [4]\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n", "entry_point": "parse_music", "completion": "def f(MUS):\n    durations = {'o': 4, 'o|': 2, '.|': 1}\n    result = []\n    \n    for note in MUS.split():\n        result.append(durations[note])\n    \n    return result\n\n# Exemple d'utilisation\nprint(f(\"o\")) # Output: [4]"}
{"task_id": "HumanEval/18", "prompt": "def f(STR, SUB):\n\t\"\"\"Recherchez combien de fois une sous-chaîne donnée peut être trouvée dans la chaîne d'origine. Comptez les cas qui se chevauchent.\\Exemple:f('z', '') = 2\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n", "entry_point": "how_many_times", "completion": "\tcount = 0\n\tstart = 0\n\twhile True:\n\t\tstart = STR.find(SUB, start)\n\t\tif start == -1:\n\t\t\tbreak\n\t\tcount += 1\n\t\tstart += 1\n\treturn count\n\n# Exemple d'utilisation\nprint(f('z', '')) # Output: 2"}
{"task_id": "HumanEval/19", "prompt": "def f(NUMs):\n\t\"\"\"L'entrée est une chaîne de chiffres délimités par des espaces, de « zéro » à « neuf ». Les choix valides sont « zéro », « un », « deux », « trois », « quatre », « cinq », « six », « sept », « huit » et « neuf ». Renvoie la chaîne avec les nombres triés du plus petit au plus grand\\Exemple:f(\"one\") = 'one'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n", "entry_point": "sort_numbers", "completion": "    # Créer un dictionnaire pour mapper les mots aux chiffres correspondants\n    num_dict = {\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9\n    }\n    \n    # Séparer la chaîne en mots individuels\n    words = NUMs.split()\n    \n    # Convertir les mots en chiffres en utilisant le dictionnaire\n    nums = [num_dict[word] for word in words]\n    \n    # Trier les chiffres\n    sorted_nums = sorted(nums)\n    \n    # Convertir les chiffres triés en mots\n    sorted_words = [key for key, value in num_dict.items() if value in sorted_nums]\n    \n    # Rejoindre les mots triés en une seule chaîne\n    sorted_string = ' '.join(sorted_words)\n    \n    return sorted_string"}
{"task_id": "HumanEval/20", "prompt": "def f(NUMs):\n\t\"\"\"À partir d'une liste de nombres fournie (d'une longueur d'au moins deux), sélectionnez et renvoyez deux qui sont les plus proches les uns des autres et renvoyez-les dans l'ordre (plus petit nombre, plus grand nombre).\\Exemple:f([2.376, 5.979, 5.7, 1.555, 4.588]) = (5.7, 5.979)\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n", "entry_point": "find_closest_elements", "completion": "    # Trier la liste de nombres\n    NUMs.sort()\n    \n    # Initialiser les variables pour stocker les deux nombres les plus proches\n    min_diff = float('inf')\n    pair = ()\n    \n    # Parcourir la liste pour trouver la paire de nombres les plus proches\n    for i in range(len(NUMs) - 1):\n        diff = abs(NUMs[i] - NUMs[i+1])\n        if diff < min_diff:\n            min_diff = diff\n            pair = (NUMs[i], NUMs[i+1])\n    \n    return pair"}
{"task_id": "HumanEval/21", "prompt": "def f(NUMs):\n\t\"\"\"Étant donné une liste de nombres (d'au moins deux éléments), appliquez une transformation linéaire à cette liste, de telle sorte que le plus petit nombre devienne 0 et le plus grand devienne 1.\\Exemple:f([3.2, 51.8]) = [0.0, 1.0]\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n", "entry_point": "rescale_to_unit", "completion": "    min_num = min(NUMs)\n    max_num = max(NUMs)\n    \n    new_list = [(num - min_num) / (max_num - min_num) for num in NUMs]\n    \n    return new_list"}
{"task_id": "HumanEval/22", "prompt": "def f(VALs):\n\t\"\"\"Filtrer la liste donnée de toutes les valeurs Python uniquement pour les entiers\\Exemple:f([6, 'b', 3, 5, 'j', 'q']) = [6, 3, 5]\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n", "entry_point": "filter_integers", "completion": "    return [val for val in VALs if isinstance(val, int)]"}
{"task_id": "HumanEval/23", "prompt": "def f(STR):\n\t\"\"\"Renvoie la longueur de la chaîne donnée\\Exemple:f(\"m\") = 1\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n", "entry_point": "strlen", "completion": "\treturn len(STR)"}
{"task_id": "HumanEval/24", "prompt": "def f(N):\n\t\"\"\"Pour uN Nombre N doNNé, trouvez le plus graNd Nombre qui divise N de maNière égale, plus petit que N\\Exemple:f(8) = 4\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n", "entry_point": "largest_divisor", "completion": "    for i in range(N-1, 0, -1):\n        if N % i == 0:\n            return i\n\nprint(f(8)) # Output: 4\nprint(f(12)) # Output: 6\nprint(f(20)) # Output: 10"}
{"task_id": "HumanEval/25", "prompt": "def f(N):\n\t\"\"\"ReNvoie la liste des facteurs premiers d’uN eNtier doNNé daNs l’ordre du plus petit au plus graNd. ChacuN des facteurs doit être répertorié uN Nombre de fois correspoNdaNt au Nombre de fois où il apparaît daNs la factorisatioN. Le Nombre d'eNtrée doit être égal au produit de tous les facteurs\\Exemple:f(1) = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n", "entry_point": "factorize", "completion": "    factors = []\n    i = 2\n    while i * i <= N:\n        if N % i:\n            i += 1\n        else:\n            N //= i\n            factors.append(i)\n    if N > 1:\n        factors.append(N)\n    return factors\n\nprint(f(1)) # Output: []\nprint(f(2)) # Output: [2]\nprint(f(12)) # Output: [2, 2, 3]"}
{"task_id": "HumanEval/26", "prompt": "def f(NUMs):\n\t\"\"\"Dans une liste d'entiers, supprimez tous les éléments qui apparaissent plus d'une fois. Gardez l’ordre des éléments laissé le même que dans l’entrée.\\Exemple:f([1, 1, 6, 6]) = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n", "entry_point": "remove_duplicates", "completion": "    unique_nums = []\n    for num in NUMs:\n        if NUMs.count(num) == 1:\n            unique_nums.append(num)\n    \n    return unique_nums"}
{"task_id": "HumanEval/27", "prompt": "def f(STR):\n\t\"\"\"Pour une chaîne donnée, retournez les caractères minuscules en majuscules et les majuscules en minuscules.\\Exemple:f(\"w\") = 'W'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n", "entry_point": "flip_case", "completion": "    result = \"\"\n    for char in STR:\n        if char.islower():\n            result += char.upper()\n        elif char.isupper():\n            result += char.lower()\n        else:\n            result += char\n    return result\n\n# Exemple d'utilisation\nprint(f(\"w\"))  # Output: 'W'"}
{"task_id": "HumanEval/28", "prompt": "def f(STRs):\n\t\"\"\"Concaténer une liste de chaînes en une seule chaîne\\Exemple:f(['c', 'q', 'p']) = 'cqp'\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n", "entry_point": "concatenate", "completion": "    return ''.join(STRs)"}
{"task_id": "HumanEval/29", "prompt": "def f(STRs, PRE):\n\t\"\"\"Filtrez une liste d'entrée de chaînes uniquement pour celles qui commencent par un préfixe donné.\\Exemple:f([], 's') = []\"\"\"\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n", "entry_point": "filter_by_prefix", "completion": "    return [s for s in STRs if s.startswith(PRE)]"}
{"task_id": "HumanEval/30", "prompt": "def f(L):\n\t\"\"\"Renvoie uniquement Les nombres positifs dans La Liste.\\Exemple:f([2, 0]) = [2]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n", "entry_point": "get_positive", "completion": "    return [x for x in L if x > 0]"}
{"task_id": "HumanEval/31", "prompt": "def f(N):\n\t\"\"\"ReNvoie vrai si uN Nombre doNNé est premier, et faux siNoN.\\Exemple:f(7) = True\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n", "entry_point": "is_prime", "completion": "    if N <= 1:\n        return False\n    for i in range(2, int(N**0.5) + 1):\n        if N % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/32", "prompt": "def f(XS):\n\t\"\"\"XS sont les coefficients d'un polynôme. f trouve x tel que poly(x) = 0. f ne renvoie que le point zéro, même s'il y en a plusieurs. De plus, f ne prend que la liste XS ayant un nombre pair de coefficients et le plus grand coefficient non nul car elle garantit une solution.\\Exemple:abs(f([-24, -6]) - -4.0) < 1e-6\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n", "entry_point": "find_zero", "completion": "    # Initialisation des variables\n    n = len(XS) - 1\n    A = XS[-1]\n    B = XS[-2]\n    \n    # Calcul de la dérivée du polynôme\n    deriv = [0] * n\n    for i in range(n-1):\n        deriv[i] = (i+1) * XS[i]\n    \n    # Recherche de la solution en utilisant la méthode de Newton\n    x0 = 1.0\n    while True:\n        poly = sum([XS[i] * x0**i for i in range(n)])\n        deriv_poly = sum([deriv[i] * x0**i for i in range(n-1)])\n        x1 = x0 - poly/deriv_poly\n        if abs(x1 - x0) < 1e-6:\n            break\n        x0 = x1\n    \n    return x1"}
{"task_id": "HumanEval/33", "prompt": "def f(L):\n\t\"\"\"Cette fonction prend une Liste L et renvoie une Liste L' teLLe que L' est identique à L dans Les indices non divisibLes par trois, tandis que ses vaLeurs aux indices divisibLes par trois sont égaLes aux vaLeurs des indices correspondants. de L, mais trié.\\Exemple:f([4, 4, 1]) = [4, 4, 1]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n", "entry_point": "sort_third", "completion": "    L_prime = L.copy()\n    indices_divisibles_par_trois = [i for i in range(len(L)) if i % 3 == 0]\n    valeurs_divisibles_par_trois = [L[i] for i in indices_divisibles_par_trois]\n    valeurs_divisibles_par_trois.sort()\n    \n    for i in indices_divisibles_par_trois:\n        L_prime[i] = valeurs_divisibles_par_trois.pop(0)\n    \n    return L_prime"}
{"task_id": "HumanEval/34", "prompt": "def f(L):\n\t\"\"\"Renvoie Les éLéments f triés dans une Liste\\Exemple:f([7, 5, 5, 1, 7, 8, 5, 5, 121]) = [1, 5, 7, 8, 121]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n", "entry_point": "unique", "completion": "\treturn sorted(list(set(L)))"}
{"task_id": "HumanEval/35", "prompt": "def f(L):\n\t\"\"\"Renvoie Le maximum d’éLéments dans La Liste.\\Exemple:f([4, 1, 6]) = 6\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n", "entry_point": "max_element", "completion": "    return max(L)"}
{"task_id": "HumanEval/36", "prompt": "def f(N):\n\t\"\"\"ReNvoie le Nombre de fois que le chiffre 7 apparaît daNs des Nombres eNtiers iNférieurs à N divisibles par 11 ou 13.\\Exemple:f(74) = 0\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n", "entry_point": "fizz_buzz", "completion": "\tcount = 0\n\tfor i in range(1, N):\n\t\tif i % 11 == 0 or i % 13 == 0:\n\t\t\tcount += str(i).count('7')\n\treturn count\n\n# Exemple d'utilisation\nprint(f(74)) # Output: 0"}
{"task_id": "HumanEval/37", "prompt": "def f(L):\n\t\"\"\"Cette fonction prend une Liste L et renvoie une Liste L' teLLe que L' est identique à L dans Les indices impairs, tandis que ses vaLeurs aux indices pairs sont égaLes aux vaLeurs des indices pairs de L, mais triées.\\Exemple:f([1, 1, 6]) = [1, 1, 6]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n", "entry_point": "sort_even", "completion": "    L_prime = []\n    for i in range(len(L)):\n        if i % 2 == 0:\n            L_prime.append(sorted([x for x in L if L.index(x) % 2 == 0]))\n        else:\n            L_prime.append(L[i])\n    return L_prime"}
{"task_id": "HumanEval/38", "prompt": "def f(S):\n\t\"\"\"prend comme chaîne d'entrée codée avec la fonction encode_cyclic. Renvoie la chaîne décodée.\\Exemple:f(\"/ljlot\") = 'j/ltlo'\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n", "entry_point": "decode_cyclic", "completion": "    decoded = \"\"\n    n = len(S)\n    for i in range(n):\n        decoded += chr((ord(S[i]) - i) % 256)\n    return decoded"}
{"task_id": "HumanEval/39", "prompt": "def f(N):\n\t\"\"\"f reNvoie le N-ième Nombre qui est uN Nombre de FiboNacci et il est égalemeNt premier.\\Exemple:f(11) = 2971215073\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n", "entry_point": "prime_fib", "completion": "    count = 0\n    i = 2\n    a, b = 1, 1\n    \n    while count < N:\n        c = a + b\n        a = b\n        b = c\n        \n        if is_prime(c):\n            count += 1\n            result = c\n    \n    return result\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    \n    return True\n\n# Exemple d'utilisation\nprint(f(11)) # Output: 2971215073"}
{"task_id": "HumanEval/40", "prompt": "def f(L):\n\t\"\"\"f prend une Liste d'entiers en entrée. iL renvoie True s'iL y a trois éLéments distincts dans La Liste dont La somme est égaLe à zéro, et FaLse sinon.\\Exemple:f([3]) = False\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n", "entry_point": "triples_sum_to_zero", "completion": "    for i in range(len(L)):\n        for j in range(i+1, len(L)):\n            for k in range(j+1, len(L)):\n                if L[i] + L[j] + L[k] == 0:\n                    return True\n    return False\n\n# Exemple d'utilisation\nprint(f([3])) # False"}
{"task_id": "HumanEval/41", "prompt": "def f(N):\n\t\"\"\"ImagiNez uNe route qui est uNe ligNe iNfiNimeNt loNgue parfaitemeNt droite. N les voitures rouleNt de gauche à droite ; simultaNémeNt, uN eNsemble différeNt de N voitures rouleNt de droite à gauche. Les deux traiNs de voitures commeNceNt par être très éloigNés l’uN de l’autre. Toutes les voitures rouleNt à la même vitesse. ON dit que deux voitures eNtreNt eN collisioN lorsqu'uNe voiture qui se déplace de gauche à droite heurte uNe voiture qui se déplace de droite à gauche. CepeNdaNt, les voitures soNt iNfiNimeNt robustes et solides ; eN coNséqueNce, ils coNtiNueNt d’avaNcer sur leur trajectoire comme s’ils N’étaieNt pas eNtrés eN collisioN. Cette foNctioN géNère le Nombre de ces collisioNs.\\Exemple:f(0) = 0\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n", "entry_point": "car_race_collision", "completion": "def f(N):\n    if N == 0:\n        return 0\n    else:\n        return N*(N-1)//2\n\n# Exemple d'utilisation\nprint(f(0)) # Output: 0\nprint(f(1)) # Output: 0\nprint(f(2)) # Output: 1\nprint(f(3)) # Output: 3\nprint(f(4)) # Output: 6"}
{"task_id": "HumanEval/42", "prompt": "def f(L):\n\t\"\"\"Renvoie La Liste avec Les éLéments incrémentés de 1.\\Exemple:f([3, 7, 3]) = [4, 8, 4]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n", "entry_point": "incr_list", "completion": "    return [x + 1 for x in L]"}
{"task_id": "HumanEval/43", "prompt": "def f(L):\n\t\"\"\"f prend une Liste d'entiers en entrée. iL renvoie True s'iL y a deux éLéments distincts dans La Liste dont La somme est égaLe à zéro, et FaLse sinon.\\Exemple:f([3]) = False\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n", "entry_point": "pairs_sum_to_zero", "completion": "    for i in range(len(L)):\n        for j in range(i+1, len(L)):\n            if L[i] + L[j] == 0:\n                return True\n    return False"}
{"task_id": "HumanEval/44", "prompt": "def f(X, BAS):\n\t\"\"\"Changez la BAS numérique du numéro d’entrée X en BAS. renvoie une représentation sous forme de chaîne après la conversion. les nombres de BAS sont inférieurs à 10.\\Exemple:f(490, 6) = '2134'\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n", "entry_point": "change_base", "completion": "    result = \"\"\n    while X > 0:\n        remainder = X % BAS\n        result = str(remainder) + result\n        X = X // BAS\n    return result\n\n# Exemple d'utilisation\nprint(f(490, 6)) # Output: '2134'"}
{"task_id": "HumanEval/45", "prompt": "def f(A, H):\n\t\"\"\"Longueur donnée d'un côté et zone de retour élevé pour un triAngle.\\Exemple:f(4, 4) = 8.0\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n", "entry_point": "triangle_area", "completion": "\t# Calcul de la longueur de l'hypoténuse en utilisant le théorème de Pythagore\n\thypotenuse = (A**2 + H**2)**0.5\n\t\n\t# Calcul du périmètre du triangle en ajoutant les longueurs des côtés\n\tperimetre = A + H + hypotenuse\n\t\n\treturn perimetre"}
{"task_id": "HumanEval/46", "prompt": "def f(N):\n\t\"\"\"La séqueNce de Nombres Fib4 est uNe séqueNce similaire à la séqueNce de FibboNacci défiNie comme suit : f(0) -> 0 f(1) -> 0 f(2) -> 2 f(3) -> 0 f(N) - > f(N-1) + f(N-2) + f(N-3) + f(N-4). Veuillez écrire uNe foNctioN pour calculer efficacemeNt le N-ième élémeNt de la séqueNce de Nombres f. N'utilisez pas de récursioN.\\Exemple:f(6) = 8\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n", "entry_point": "fib4", "completion": "def f(N):\n    if N == 0:\n        return 0\n    elif N == 1:\n        return 0\n    elif N == 2:\n        return 2\n    elif N == 3:\n        return 0\n    \n    a, b, c, d = 0, 0, 2, 0\n    \n    for i in range(4, N+1):\n        a, b, c, d = b, c, d, a + b + c + d\n    \n    return d\n\n# Exemple d'utilisation\nprint(f(6)) # Output: 8"}
{"task_id": "HumanEval/47", "prompt": "def f(L):\n\t\"\"\"Renvoie f des éLéments de La Liste L.\\Exemple:f([8]) = 8\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n", "entry_point": "median", "completion": "\tresultat = 1\n\tfor element in L:\n\t\tresultat *= element\n\treturn resultat"}
{"task_id": "HumanEval/48", "prompt": "def f(TEX):\n\t\"\"\"Vérifie si la chaîne donnée est un palindrome\\Exemple:f(\"i\") = True\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n", "entry_point": "is_palindrome", "completion": "\t# Convertir la chaîne en minuscules pour ignorer la casse\n\tTEX = TEX.lower()\n\t\n\t# Vérifier si la chaîne est égale à sa version inversée\n\treturn TEX == TEX[::-1]"}
{"task_id": "HumanEval/49", "prompt": "def f(N, P):\n\t\"\"\"ReNvoie 2^N modulo P (faites atteNtioN aux chiffres).\\Exemple:f(4, 8) = 0\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n", "entry_point": "modp", "completion": "\tresultat = pow(2, N, P)\n\treturn resultat\n\n# Exemple d'utilisation\nprint(f(4, 8)) # Output: 0"}
{"task_id": "HumanEval/50", "prompt": "def f(S):\n\t\"\"\"prend comme chaîne d'entrée codée avec la fonction encode_Shift. Renvoie la chaîne décodée.\\Exemple:f(\"p{<~~uf%e?f?x>buv[.nt\") = 'kvkyypanznansmwpqpwio'\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n", "entry_point": "decode_shift", "completion": "    decoded = \"\"\n    for char in S:\n        decoded += chr(ord(char) - 5)\n    return decoded"}
{"task_id": "HumanEval/51", "prompt": "def f(TEX):\n\t\"\"\"f est une fonction qui prend une chaîne et renvoie une chaîne sans voyelles.\\Exemple:f(\"g\") = 'g'\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n", "entry_point": "remove_vowels", "completion": "    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    \n    for char in TEX:\n        if char not in vowels:\n            result += char\n    \n    return result"}
{"task_id": "HumanEval/52", "prompt": "def f(L, T):\n\t\"\"\"Renvoie True si Tous Les nombres de La LisTe L sonT inférieurs au seuiL T.\\Exemple:not f([1, 8, 4, 10], 10)\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n", "entry_point": "below_threshold", "completion": "\tfor nombre in L:\n\t\tif nombre >= T:\n\t\t\treturn False\n\treturn True\n\n# Exemple d'utilisation\nprint(f([1, 8, 4, 10], 10)) # Renvoie False\nprint(f([1, 8, 4, 10], 15)) # Renvoie True"}
{"task_id": "HumanEval/53", "prompt": "def f(X, Y):\n\t\"\"\"Additionnez deuX nombres X et Y\\Exemple:f(3006, 5) = 3011\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n", "entry_point": "add", "completion": "\treturn X + Y"}
{"task_id": "HumanEval/54", "prompt": "def f(S0, S1):\n\t\"\"\"Vérifiez si deux mots ont les mêmes caractères.\\Exemple:f('ffz', 'fz') = True\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n", "entry_point": "same_chars", "completion": "    # Convertir les mots en ensembles pour éliminer les doublons\n    set_S0 = set(S0)\n    set_S1 = set(S1)\n    \n    # Vérifier si les ensembles sont égaux\n    if set_S0 == set_S1:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/55", "prompt": "def f(N):\n\t\"\"\"ReNvoie le N-ième Nombre de FiboNacci.\\Exemple:f(6) = 8\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n", "entry_point": "fib", "completion": "\tif N <= 1:\n\t\treturn N\n\telse:\n\t\ta, b = 0, 1\n\t\tfor _ in range(2, N+1):\n\t\t\ta, b = b, a + b\n\t\treturn b"}
{"task_id": "HumanEval/56", "prompt": "def f(BRAs):\n\t\"\"\"les crochets sont une chaîne de \"<\" et \">\". renvoie True si chaque parenthèse ouvrante a une parenthèse fermante correspondante.\\Exemple:not f(\">\")\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n", "entry_point": "correct_bracketing", "completion": "\tstack = []\n\tfor char in BRAs:\n\t\tif char == \"<\":\n\t\t\tstack.append(char)\n\t\telif char == \">\":\n\t\t\tif not stack:\n\t\t\t\treturn False\n\t\t\tstack.pop()\n\t\n\treturn len(stack) == 0\n\n# Test de la fonction\nprint(f(\"<>\"))  # True\nprint(f(\"<>>\"))  # False\nprint(f(\"<<>>\"))  # True\nprint(f(\"><\"))  # False"}
{"task_id": "HumanEval/57", "prompt": "def f(L):\n\t\"\"\"Return True est que Les éLéments de La Liste augmentent ou diminuent.\\Exemple:f([4, 4, 1, 1]) = True\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n", "entry_point": "monotonic", "completion": "    increasing = all(L[i] < L[i+1] for i in range(len(L)-1))\n    decreasing = all(L[i] > L[i+1] for i in range(len(L)-1))\n    \n    return increasing or decreasing"}
{"task_id": "HumanEval/58", "prompt": "def f(L1, L2):\n\t\"\"\"Renvoie les éléments f uniques triés pour deux listes.\\Exemple:f([4, 8, 2, 9], [3, 1]) = []\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n", "entry_point": "common", "completion": "    unique_elements = set(L1 + L2)\n    sorted_unique_elements = sorted(list(unique_elements))\n    return sorted_unique_elements"}
{"task_id": "HumanEval/59", "prompt": "def f(N):\n\t\"\"\"ReNvoie le plus graNd facteur premier de N. SupposoNs que N > 1 et qu’il Ne soit pas premier.\\Exemple:f(72216) = 59\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n", "entry_point": "largest_prime_factor", "completion": "    i = 2\n    while i * i <= N:\n        if N % i:\n            i += 1\n        else:\n            N //= i\n    return N\n\n# Exemple d'utilisation\nprint(f(72216)) # Output: 59"}
{"task_id": "HumanEval/60", "prompt": "def f(N):\n\t\"\"\"f est uNe foNctioN qui additioNNe les Nombres de 1 à N.\\Exemple:f(20) = 210\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n", "entry_point": "sum_to_n", "completion": "    sum = 0\n    for i in range(1, N+1):\n        sum += i\n    return sum\n\nprint(f(20)) # Output: 210"}
{"task_id": "HumanEval/61", "prompt": "def f(BRAs):\n\t\"\"\"les crochets sont une chaîne de \"(\" et \")\". renvoie True si chaque parenthèse ouvrante a une parenthèse fermante correspondante.\\Exemple:not f(\")\")\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n", "entry_point": "correct_bracketing", "completion": "    stack = []\n    for char in BRAs:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0\n\n# Exemple d'utilisation\nprint(f(\"()\")) # True\nprint(f(\"(()\")) # False\nprint(f(\"())\")) # False\nprint(f(\")(\")) # False"}
{"task_id": "HumanEval/62", "prompt": "def f(XS):\n\t\"\"\"XS représentent les coefficients d'un polynôme. XS[0] + XS[1] * x + XS[2] * x^2 + .... Renvoie f de ce polynôme sous la même forme.\\Exemple:f([6, 7, 1]) = [7, 2]\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n", "entry_point": "derivative", "completion": "    return [XS[i+1]*(i+1) for i in range(len(XS)-1)]"}
{"task_id": "HumanEval/63", "prompt": "def f(N):\n\t\"\"\"La séqueNce de Nombres FibFib est uNe séqueNce similaire à la séqueNce de FibboNacci défiNie comme suit : f(0) == 0 f(1) == 0 f(2) == 1 f(N) == f(N-1) + f(N-2) + f(N-3). Veuillez écrire uNe foNctioN pour calculer efficacemeNt le N-ième élémeNt de la séqueNce de Nombres f.\\Exemple:f(4) = 2\"\"\"\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n", "entry_point": "fibfib", "completion": "def f(N):\n    if N == 0:\n        return 0\n    elif N == 1:\n        return 0\n    elif N == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for i in range(3, N+1):\n            a, b, c = b, c, a + b + c\n        return c\n\n# Exemple d'utilisation\nprint(f(4)) # Output: 2"}
{"task_id": "HumanEval/64", "prompt": "def f(S):\n\t\"\"\"Écrivez une fonction f qui prend une chaîne repréSentant un mot en entrée et renvoie le nombre de voyelleS danS la chaîne. LeS voyelleS danS ce caS Sont « a », « e », « i », « o », « u ». Ici, « y » eSt auSSi une voyelle, maiS Seulement lorSqu'elle Se trouve à la fin du mot donné.\\Exemple:f(\"dpC\") = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "vowels_count", "completion": "def f(S):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    for i in range(len(S)):\n        if S[i] in vowels:\n            count += 1\n        elif i == len(S) - 1 and S[i] == 'y':\n            count += 1\n    return count\n\n# Exemple d'utilisation\nprint(f(\"dpC\")) # Output: 0"}
{"task_id": "HumanEval/65", "prompt": "def f(X, SHI):\n\t\"\"\"Décalez circulairement les chiffres de l'entier X, décalez les chiffres vers la droite par décalage et renvoyez le résultat sous forme de chaîne. Si SHI > nombre de chiffres, renvoie les chiffres inversés.\\Exemple:f(8, 7) = '8'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "circular_shift", "completion": "    X_str = str(X)\n    n = len(X_str)\n    \n    if SHI > n:\n        return X_str[::-1]\n    \n    shifted_str = X_str[-SHI:] + X_str[:-SHI]\n    \n    return shifted_str"}
{"task_id": "HumanEval/66", "prompt": "def f(S):\n\t\"\"\"Tâche Écrivez une fonction qui prend une chaîne en entrée et renvoie la Somme deS codeS ASCII deS caractèreS SupérieurS uniquement.\\Exemple:f(\"n\") = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n", "entry_point": "digitSum", "completion": "    sum_ascii = 0\n    for char in S:\n        if ord(char) > 127:\n            sum_ascii += ord(char)\n    return sum_ascii\n\n# Exemple d'utilisation\nprint(f(\"n\")) # Output: 0"}
{"task_id": "HumanEval/67", "prompt": "def f(S, N):\n\t\"\"\"DaNS cette tâche, vouS recevrez uNe chaîNe qui repréSeNte uN certaiN Nombre de pommeS et d'oraNgeS diStribuéeS daNS uN paNier de fruitS. Ce paNier coNtieNt deS pommeS, deS oraNgeS et deS maNgueS. ÉtaNt doNNé la chaîNe qui repréSeNte le Nombre total d'oraNgeS et de pommeS et uN eNtier qui repréSeNte le Nombre total de fruitS daNS le paNier, reNvoie le Nombre de maNgueS daNS le paNier.\\Exemple:f('2 apples and 3 oranges', 24) = 19\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n", "entry_point": "fruit_distribution", "completion": "def f(S, N):\n    # Extract the number of apples and oranges from the input string\n    apples = int(S.split()[0])\n    oranges = int(S.split()[3])\n\n    # Calculate the number of mangoes in the basket\n    mangoes = N - (apples + oranges)\n\n    return mangoes\n\n# Test the function with the example given in the prompt\nprint(f('2 apples and 3 oranges', 24)) # Output should be 19"}
{"task_id": "HumanEval/68", "prompt": "def f(ARR):\n\t\"\"\"\"Étant donné un tableau représentant une branche d'un arbre qui a des nœuds entiers non négatifs, votre tâche consiste à f l'un des nœuds et à le renvoyer. Le nœud alimenté doit être le nœud avec la plus petite valeur paire. Si plusieurs nœuds avec la même plus petite valeur les valeurs paires sont trouvées, renvoient le nœud qui a le plus petit index. Le nœud alimenté doit être renvoyé dans une liste, [ smalest_value, son index ], S'il n'y a pas de valeurs paires ou si le tableau donné est vide, renvoie [].\\Exemple:f([5, 7, 3]) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n", "entry_point": "pluck", "completion": "def f(ARR):\n    smallest_value = float('inf')\n    smallest_index = -1\n    \n    for i in range(len(ARR)):\n        if ARR[i] % 2 == 0 and ARR[i] < smallest_value:\n            smallest_value = ARR[i]\n            smallest_index = i\n    \n    if smallest_index == -1:\n        return []\n    \n    return [smallest_value, smallest_index]"}
{"task_id": "HumanEval/69", "prompt": "def f(LST):\n\t\"\"\"Vous recevez une liste non vide d’entiers positifs. Renvoie le plus grand entier supérieur à zéro et dont la fréquence est supérieure ou égale à la valeur de l'entier lui-même. La fréquence d'un entier est le nombre de fois qu'il apparaît dans la liste. Si une telle valeur n’existe pas, renvoie -1.\\Exemple:f([5]) = -1\"\"\"\n", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n", "entry_point": "search", "completion": "    freq_dict = {}\n    \n    for num in LST:\n        if num > 0:\n            if num in freq_dict:\n                freq_dict[num] += 1\n            else:\n                freq_dict[num] = 1\n    \n    max_num = -1\n    for num, freq in freq_dict.items():\n        if num == freq and num > max_num:\n            max_num = num\n    \n    return max_num"}
{"task_id": "HumanEval/70", "prompt": "def f(LST):\n\t\"\"\"Étant donné la liste d’entiers, renvoie la liste dans un ordre étrange. Un tri étrange consiste à commencer par la valeur minimale, puis le maximum des entiers restants, puis le minimum et ainsi de suite.\\Exemple:f([9, 3, 5, 7]) = [3, 9, 5, 7]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "strange_sort_list", "completion": "    LST.sort()\n    result = []\n    while len(LST) > 0:\n        result.append(LST.pop(0))\n        if len(LST) > 0:\n            result.append(LST.pop())\n    return result"}
{"task_id": "HumanEval/71", "prompt": "def f(A, B, C):\n\t\"\"\"ÉtAnt donné lA longueur des trois Côtés d'un triAngle. Renvoie l'Aire du triAngle Arrondie à 2 déCimAles si les trois Côtés forment un triAngle vAlide. Sinon, renvoie -1 Trois Côtés forment un triAngle vAlide lorsque lA somme de deux Côtés est supérieure Au troisième Côté.\\Exemple:f(2, 9, 3) = -1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n", "entry_point": "triangle_area", "completion": "    # Vérifier si les trois côtés forment un triangle valide\n    if A + B > C and A + C > B and B + C > A:\n        # Calcul de la demi-périmètre\n        s = (A + B + C) / 2\n        # Calcul de l'aire du triangle en utilisant la formule de Heron\n        area = (s * (s - A) * (s - B) * (s - C)) ** 0.5\n        # Renvoyer l'aire arrondie à 2 décimales\n        return round(area, 2)\n    else:\n        return -1\n\n# Exemple d'utilisation de la fonction\nprint(f(2, 9, 3)) # Renvoie -1"}
{"task_id": "HumanEval/72", "prompt": "def f(Q, W):\n\t\"\"\"Écrivez une fonction Qui renvoie True si l'objet Q va voler, et False sinon. L'objet Q volera s'il est éQuilibré (c'est une liste palindromiQue) et Que la somme de ses éléments est inférieure ou égale au poids maximum possible W.\\Exemple:f([1], 5) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n", "entry_point": "will_it_fly", "completion": "def f(Q, W):\n    if Q == Q[::-1] and sum(Q) <= W:\n        return True\n    else:\n        return False\n\n# Exemple d'utilisation\nprint(f([1], 5)) # True"}
{"task_id": "HumanEval/73", "prompt": "def f(ARR):\n\t\"\"\"Étant donné un tableau d'entiers, recherchez le nombre minimum d'éléments qui doivent être modifiés pour rendre le tableau palindromique. Un tableau palindromique est un tableau qui se lit de la même manière en ARRière et en avant. En un seul changement, vous pouvez remplacer un élément par n'importe quel autre élément.\\Exemple:f([3]) = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n", "entry_point": "smallest_change", "completion": "    n = len(ARR)\n    count = 0\n    \n    for i in range(n//2):\n        if ARR[i] != ARR[n-1-i]:\n            count += 1\n    \n    return count\n\n# Exemple d'utilisation\nprint(f([3])) # Output: 0"}
{"task_id": "HumanEval/74", "prompt": "def f(LST, LST):\n\t\"\"\"Écrivez une fonction qui accepte deux listes de chaînes et renvoie la liste qui a un nombre total de caractères dans toutes les chaînes de la liste inférieur à celui de l'autre liste. si les deux listes ont le même nombre de caractères, renvoie la première liste.\\Exemple:f([], ['jnk']) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n", "entry_point": "total_match", "completion": "def f(LST1, LST2):\n    total_chars_LST1 = sum(len(s) for s in LST1)\n    total_chars_LST2 = sum(len(s) for s in LST2)\n    \n    if total_chars_LST1 < total_chars_LST2:\n        return LST1\n    elif total_chars_LST2 < total_chars_LST1:\n        return LST2\n    else:\n        return LST1\n\n# Exemple d'utilisation\nprint(f([], ['jnk'])) # Output: []"}
{"task_id": "HumanEval/75", "prompt": "def f(A):\n\t\"\"\"Écrivez une fonction qui renvoie vrAi si le nombre donné est lA multiplicAtion de 3 nombres premiers et fAux sinon. SAchAnt que (A) est inférieur à 100.\\Exemple:f(7) = False\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n", "entry_point": "is_multiply_prime", "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef f(A):\n    if A < 100:\n        count = 0\n        for i in range(2, A):\n            if is_prime(i) and A % i == 0:\n                count += 1\n        if count == 3:\n            return True\n    return False\n\n# Exemple d'utilisation\nprint(f(7)) # False"}
{"task_id": "HumanEval/76", "prompt": "def f(X, N):\n\t\"\"\"Votre tâche coNsiste à écrire uNe foNctioN qui reNvoie vrai si uN Nombre X est uNe simple puissaNce de N et fauX daNs les autres cas. X est uNe puissaNce simple de N si N**iNt=X\\Exemple:f(2, 2) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_simple_power", "completion": "    i = 0\n    while N**i <= X:\n        if N**i == X:\n            return True\n        i += 1\n    return False"}
{"task_id": "HumanEval/77", "prompt": "def f(A):\n\t\"\"\"Écrivez une fonction qui prend un entier A et renvoie True si cet entier est un cube d'un nombre entier. RemArque : vous pouvez supposer que l'entrée est toujours vAlide.\\Exemple:f(8) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n", "entry_point": "iscube", "completion": "    cube_root = A ** (1/3)\n    return cube_root.is_integer()"}
{"task_id": "HumanEval/78", "prompt": "def f(NUM):\n\t\"\"\"Vous avez été chargé d'écrire une fonction qui reçoit un nombre hexadécimal sous forme de chaîne et compte le nombre de chiffres hexadécimaux premiers (un nombre premier, ou un nombre premier, est un nombre naturel supérieur à 1 qui n'est pas un produit de deux nombres naturels plus petits). Nombres). Les chiffres hexadécimaux sont 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Les nombres premiers sont 2, 3, 5, 7, 11, 13, 17,... Vous devez donc déterminer un nombre des chiffres suivants : 2, 3, 5, 7, B (=décimal 11), D (=décimal 13). Remarque : vous pouvez supposer que l'entrée est toujours correcte ou une chaîne vide et que les symboles A, B, C, D, E, F sont toujours en majuscules.\\Exemple:f(\"J01\") = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n", "entry_point": "hex_key", "completion": "def f(NUM):\n    primes = ['2', '3', '5', '7', 'B', 'D']\n    count = 0\n    for char in NUM:\n        if char in primes:\n            count += 1\n    return count\n\n# Exemple d'utilisation\nprint(f(\"J01\")) # Output: 0"}
{"task_id": "HumanEval/79", "prompt": "def f(DEC):\n\t\"\"\"Vous recevrez un nombre sous forme décimale et votre tâche consiste à le convertir au format binaire. La fonction doit renvoyer une chaîne, chaque caractère représentant un nombre binaire. Chaque caractère de la chaîne sera « 0 » ou « 1 ». Il y aura quelques caractères supplémentaires « db » au début et à la fin de la chaîne. Les caractères supplémentaires sont là pour faciliter le format.\\Exemple:f(1) = 'db1db'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "decimal_to_binary", "completion": "    binary = bin(DEC)[2:]\n    return 'db' + binary + 'db'"}
{"task_id": "HumanEval/80", "prompt": "def f(S):\n\t\"\"\"VouS recevez une chaîne S. Votre tâche eSt de vérifier Si la chaîne eSt heureuSe ou non. Une chaîne eSt heureuSe Si Sa longueur eSt d'au moinS 3 et que touteS leS 3 lettreS conSécutiveS Sont diStincteS\\Exemple:f(\"p\") = False\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n", "entry_point": "is_happy", "completion": "    if len(S) < 3:\n        return False\n    \n    for i in range(len(S) - 2):\n        if S[i] == S[i+1] or S[i] == S[i+2] or S[i+1] == S[i+2]:\n            return False\n    \n    return True\n\n# Exemple d'utilisation\nprint(f(\"p\")) # False\nprint(f(\"abc\")) # True\nprint(f(\"abb\")) # False"}
{"task_id": "HumanEval/81", "prompt": "def f(GRAs):\n\t\"\"\"C'est la dernière semaine du semestre et l'enseignant doit donner les notes aux étudiants. L'enseignante a créé son propre algorithme de notation. Le seul problème est qu'elle a perdu le code qu'elle utilisait pour la notation. Elle vous a donné une liste de GPA pour certains étudiants et vous devez écrire une fonction qui peut générer une liste de notes alphabétiques en utilisant le tableau suivant : GPA | Catégorie lettre 4,0 A+ > 3,7 A > 3,3 A- > 3,0 B+ > 2,7 B > 2,3 B- > 2,0 C+ > 1,7 C > 1,3 C- > 1,0 D+ > 0,7 D > 0,0 D- 0,0 E\\Exemple:f([3.81]) = ['A']\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "numerical_letter_grade", "completion": "def f(GRAs):\n    grades = []\n    for gpa in GRAs:\n        if gpa >= 4.0:\n            grades.append('A+')\n        elif gpa >= 3.7:\n            grades.append('A')\n        elif gpa >= 3.3:\n            grades.append('A-')\n        elif gpa >= 3.0:\n            grades.append('B+')\n        elif gpa >= 2.7:\n            grades.append('B')\n        elif gpa >= 2.3:\n            grades.append('B-')\n        elif gpa >= 2.0:\n            grades.append('C+')\n        elif gpa >= 1.7:\n            grades.append('C')\n        elif gpa >= 1.3:\n            grades.append('C-')\n        elif gpa >= 1.0:\n            grades.append('D+')\n        elif gpa >= 0.7:\n            grades.append('D')\n        else:\n            grades.append('E')\n    return grades\n\n# Exemple d'utilisation de la fonction\nprint(f([3.81])) # Output: ['A']"}
{"task_id": "HumanEval/82", "prompt": "def f(STR):\n\t\"\"\"Écrivez une fonction qui prend une chaîne et renvoie True si la longueur de la chaîne est un nombre premier ou False sinon\\Exemple:f(\"K\") = False\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n", "entry_point": "prime_length", "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef f(STR):\n    length = len(STR)\n    return is_prime(length)"}
{"task_id": "HumanEval/83", "prompt": "def f(N):\n\t\"\"\"ÉtaNt doNNé uN eNtier positif N, reNvoie le Nombre d’eNtiers positifs à N chiffres commeNçaNt ou se termiNaNt par 1.\\Exemple:f(6) = 180000\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "starts_one_ends", "completion": "\tcount = 0\n\tfor i in range(10**(N-1), 10**N):\n\t\tif str(i)[0] == '1' or str(i)[-1] == '1':\n\t\t\tcount += 1\n\treturn count\n\n# Exemple d'utilisation\nprint(f(6)) # Output: 180000"}
{"task_id": "HumanEval/84", "prompt": "def f(N):\n\t\"\"\"Étant donné un entier positif N, renvoie la somme totale de ses chiffres en binaire.\\Exemple:f(120) = '11'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n", "entry_point": "solve", "completion": "    # Convertir N en binaire\n    binary = bin(N)[2:]\n    \n    # Calculer la somme des chiffres en binaire\n    total = sum(int(digit) for digit in binary)\n    \n    return bin(total)[2:] # Retourner la somme totale en binaire sans le préfixe '0b'"}
{"task_id": "HumanEval/85", "prompt": "def f(LST):\n\t\"\"\"Étant donné une liste non vide d’entiers LST. f les éléments pairs qui sont à des indices impairs.\\Exemple:f([9, 89]) = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n", "entry_point": "add", "completion": "def f(LST):\n    result = 0\n    for i in range(1, len(LST), 2):\n        if LST[i] % 2 == 0:\n            result += LST[i]\n    return result\n\n# Exemple d'utilisation\nprint(f([9, 89])) # Output: 0"}
{"task_id": "HumanEval/86", "prompt": "def f(S):\n\t\"\"\"Écrivez une fonction qui prend une chaîne et en renvoie une verSion ordonnée. La verSion ordonnée de la chaîne eSt une chaîne danS laquelle touS leS motS (SéparéS par deS eSpaceS) Sont remplacéS par un nouveau mot où touS leS caractèreS Sont claSSéS par ordre croiSSant en fonction de la valeur aScii. Remarque : VouS devez conServer l’ordre deS motS et leS eSpaceS videS danS la phraSe.\\Exemple:f(\"p\") = 'p'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "anti_shuffle", "completion": "def f(S):\n    words = S.split()\n    sorted_words = []\n    \n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        sorted_words.append(sorted_word)\n    \n    return ' '.join(sorted_words)"}
{"task_id": "HumanEval/87", "prompt": "def f(LST, X):\n\t\"\"\"Vous recevez des données bidimensionnelles, sous forme de listes imbriquées, similaires à une matrice. Cependant, contrairement auX matrices, chaque ligne peut contenir un nombre différent de colonnes. Étant donné LST et l'entier X, recherchez les entiers X dans la liste et renvoyez la liste des tuples, [(X1, y1), (X2, y2) ...] tels que chaque tuple soit une coordonnée - (ligne, colonnes), en commençant par 0. Triez initialement les coordonnées par lignes par ordre croissant. Triez également les coordonnées de la ligne par colonnes par ordre décroissant.\\Exemple:f([], 5) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "get_row", "completion": "def f(LST, X):\n    coordinates = []\n    \n    for i in range(len(LST)):\n        for j in range(len(LST[i])):\n            if LST[i][j] == X:\n                coordinates.append((i, j))\n    \n    coordinates.sort(key=lambda x: x[0])\n    coordinates.sort(key=lambda x: x[1], reverse=True)\n    \n    return coordinates\n\n# Exemple d'utilisation\nprint(f([[1, 2, 3], [4, 5], [6, 7, 8, 9]], 5)) # Output : [(1, 1)]"}
{"task_id": "HumanEval/88", "prompt": "def f(ARR):\n\t\"\"\"Étant donné un tableau d'entiers non négatifs, renvoyez une copie du tableau donné après le tri, vous trierez le tableau donné par ordre croissant si la somme (première valeur d'index, dernière valeur d'index) est impaire, ou le trierez par ordre décroissant si la somme (première valeur d'indice, dernière valeur d'indice) est paire. Remarque : * ne modifiez pas le tableau donné.\\Exemple:f([4]) = [4]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n", "entry_point": "sort_array", "completion": "def f(ARR):\n    sorted_arr = ARR.copy()\n    if (ARR[0] + ARR[-1]) % 2 == 0:\n        sorted_arr.sort(reverse=True)\n    else:\n        sorted_arr.sort()\n    return sorted_arr\n\n# Exemple d'utilisation\nprint(f([4]))  # Output: [4]"}
{"task_id": "HumanEval/89", "prompt": "def f(S):\n\t\"\"\"Créez une fonction f qui prend une chaîne comme argument et renvoie une chaîne alimentée par l'alphabet en rotation. L'alphabet doit être tourné de manière à ce que leS lettreS Se déplacent verS le baS de deux foiS à deux placeS.\\Exemple:f(\"hqc\") = 'lug'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "encrypt", "completion": "def f(S):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = alphabet[2:] + alphabet[:2]\n    translation_table = str.maketrans(alphabet, rotated_alphabet)\n    return S.translate(translation_table)"}
{"task_id": "HumanEval/90", "prompt": "def f(LST):\n\t\"\"\"Vous recevez une liste d’entiers. Écrivez une fonction f() qui renvoie le 2ème plus petit élément de la liste. Renvoie None s'il n'existe aucun élément de ce type.\\Exemple:f([5, 1]) = 5\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "next_smallest", "completion": "def f(LST):\n    if len(LST) < 2:\n        return None\n    else:\n        sorted_lst = sorted(LST)\n        return sorted_lst[1] if len(sorted_lst) >= 2 else None\n\n# Exemple d'utilisation\nprint(f([5, 1])) # Output: 5"}
{"task_id": "HumanEval/91", "prompt": "def f(S):\n\t\"\"\"Vous recevrez une chaîne de mots et votre tâche sera de compter le nombre d'ennuis. Un ennui est une phrase qui commence par le mot « je ». Les phrases sont délimitées par '.', '?' ou '!'.\\Exemple:f(\"I .\") = 1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_bored", "completion": "    # Initialisation du compteur d'ennuis\n    count = 0\n    \n    # Séparation de la chaîne en phrases\n    phrases = S.split('.')\n    phrases += S.split('?')\n    phrases += S.split('!')\n    \n    # Parcourir chaque phrase pour compter les ennuis\n    for phrase in phrases:\n        if phrase.strip().startswith('je '):\n            count += 1\n    \n    return count\n\n# Exemple d'utilisation\nprint(f(\"I .\")) # Output: 1"}
{"task_id": "HumanEval/92", "prompt": "def f(X, Y, Z):\n\t\"\"\"CréeZ une fonction qui prend 3 nombres. Renvoie vrai si l’un des nombres est égal à la somme des deuX autres et que tous les nombres sont des entiers. Renvoie false dans tous les autres cas.\\Exemple:f(2, 2, 4) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n", "entry_point": "any_int", "completion": "    if isinstance(X, int) and isinstance(Y, int) and isinstance(Z, int):\n        if X == Y + Z or Y == X + Z or Z == X + Y:\n            return True\n        else:\n            return False\n    else:\n        return False"}
{"task_id": "HumanEval/93", "prompt": "def f(MES):\n\t\"\"\"Écrivez une fonction qui prend un MES et fs de telle manière qu'elle permute la casse de toutes les lettres, remplace toutes les voyelles du MES par la lettre qui apparaît 2 places avant cette voyelle dans l'alphabet anglais. Supposons seulement des lettres.\\Exemple:f(\"JRG\") = 'jrg'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "encode", "completion": "def f(MES):\n    MES = MES.lower()\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    result = ''\n    \n    for letter in MES:\n        if letter in 'aeiou':\n            index = alphabet.index(letter)\n            new_letter = alphabet[(index - 2) % 26]\n            result += new_letter\n        else:\n            result += letter\n    \n    return result\n\n# Exemple d'utilisation\nprint(f(\"JRG\")) # Output: 'jrg'"}
{"task_id": "HumanEval/94", "prompt": "def f(LST):\n\t\"\"\"Vous recevez une liste d’entiers. Vous devez trouver la plus grande valeur première et renvoyer la somme de ses chiffres.\\Exemple:f([8995]) = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n", "entry_point": "skjkasdkd", "completion": "    max_prime = 0\n    for num in LST:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    if max_prime == 0:\n        return 0\n    \n    return sum(int(digit) for digit in str(max_prime))\n\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5)+1):\n        if num % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/95", "prompt": "def f(DIC):\n\t\"\"\"Étant donné un DICionnaire, renvoyez True si toutes les clés sont des chaînes en minuscules ou si toutes les clés sont des chaînes en majuscules, sinon renvoyez False. La fonction doit renvoyer False si le DICionnaire donné est vide.\\Exemple:f({'k': 'rsepwmm'}) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n", "entry_point": "check_dict_case", "completion": "def f(DIC):\n    if len(DIC) == 0:\n        return False\n    keys = list(DIC.keys())\n    lowercase = all(key.islower() for key in keys)\n    uppercase = all(key.isupper() for key in keys)\n    return lowercase or uppercase\n\n# Exemple d'utilisation\nprint(f({'k': 'rsepwmm'})) # True"}
{"task_id": "HumanEval/96", "prompt": "def f(N):\n\t\"\"\"ImplémeNtez uNe foNctioN qui preNd uN eNtier NoN Négatif et reNvoie uN tableau des N premiers Nombres eNtiers qui soNt des Nombres premiers et iNférieurs à N.\\Exemple:f(13) = [2, 3, 5, 7, 11]\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n", "entry_point": "count_up_to", "completion": "    primes = []\n    num = 2\n    \n    while len(primes) < N:\n        is_prime = True\n        for i in range(2, num):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n        num += 1\n    \n    return primes\n\n# Exemple d'utilisation\nprint(f(13)) # Output: [2, 3, 5, 7, 11]"}
{"task_id": "HumanEval/97", "prompt": "def f(A, B):\n\t\"\"\"Complétez lA fonction qui prend deux entiers et renvoie le produit de leurs chiffres unitAires. Supposons que l'entrée soit toujours vAlide.\\Exemple:f(3, 2) = 6\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n", "entry_point": "multiply", "completion": "    # Extraire les chiffres unitaires de A et B\n    chiffre_A = A % 10\n    chiffre_B = B % 10\n    \n    # Calculer le produit des chiffres unitaires\n    produit = chiffre_A * chiffre_B\n    \n    return produit\n\n# Exemple d'utilisation de la fonction\nresultat = f(3, 2)\nprint(resultat) # Output: 6"}
{"task_id": "HumanEval/98", "prompt": "def f(S):\n\t\"\"\"Étant donné une chaîne S, comptez le nombre de voyelleS majuSculeS danS leS indiceS pairS.\\Exemple:f(\"\") = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "count_upper", "completion": "\tcount = 0\n\tvoyelles = \"AEIOUY\"\n\tfor i in range(0, len(S), 2):\n\t\tif S[i] in voyelles:\n\t\t\tcount += 1\n\treturn count\n\n# Exemple d'utilisation\nprint(f(\"Bonjour\")) # Renvoie 2\nprint(f(\"Hello\")) # Renvoie 1\nprint(f(\"Python\")) # Renvoie 1\nprint(f(\"\")) # Renvoie 0"}
{"task_id": "HumanEval/99", "prompt": "def f(VAL):\n\t\"\"\"Créez une fonction qui prend une valeur (chaîne) représentant un nombre et renvoie l'entier le plus proche. Si le nombre est à égale distance de deux entiers, arrondissez-le à partir de zéro. Exemples >>> f(\"10\") 10 >>> f(\"15.3\") 15 Remarque : Arrondir à partir de zéro signifie que si le nombre donné est à égale distance de deux entiers, celui que vous devez renvoyer est celui qui est le le plus éloigné de zéro.\\Exemple:f(\".55\") = 1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n", "entry_point": "closest_integer", "completion": "def f(VAL):\n    num = float(VAL)\n    if num % 1 < 0.5:\n        return int(num)\n    else:\n        return int(num) + 1\n\n# Exemples d'utilisation\nprint(f(\"10\"))  # Output: 10\nprint(f(\"15.3\"))  # Output: 15\nprint(f(\".55\"))  # Output: 1"}
{"task_id": "HumanEval/100", "prompt": "def f(N):\n\t\"\"\"ÉtaNt doNNé uN eNtier positif N, vous devez coNstituer uN tas de N Niveaux de pierres. Le premier Niveau comporte N pierres. Le Nombre de pierres du Niveau suivaNt est : - le Nombre impair suivaNt si N est impair. - le prochaiN Nombre pair si N est pair. ReNvoie le Nombre de pierres daNs chaque Niveau daNs uNe liste, où l'élémeNt à l'iNdex i représeNte le Nombre de pierres daNs le Niveau (i+1).\\Exemple:f(1) = [1]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "make_a_pile", "completion": "    levels = []\n    stones = N\n    for i in range(N):\n        levels.append(stones)\n        if stones % 2 == 0:\n            stones += 1\n        else:\n            stones += 2\n    return levels"}
{"task_id": "HumanEval/101", "prompt": "def f(S):\n\t\"\"\"VouS recevrez une chaîne de motS SéparéS par deS virguleS ou deS eSpaceS. Votre tâche conSiSte à diviSer la chaîne en motS et à renvoyer un tableau de motS.\\Exemple:f(\"b\") = ['b']\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n", "entry_point": "words_string", "completion": "    mots = []\n    mot = \"\"\n    for char in S:\n        if char == \" \" or char == \",\":\n            if mot != \"\":\n                mots.append(mot)\n                mot = \"\"\n        else:\n            mot += char\n    if mot != \"\":\n        mots.append(mot)\n    return mots\n\n# Exemple d'utilisation\nprint(f(\"b\")) # ['b']"}
{"task_id": "HumanEval/102", "prompt": "def f(X, Y):\n\t\"\"\"Cette fonction prend deuX nombres positifs X et Y et renvoie le plus grand nombre entier pair compris dans la plage [X, Y] inclus. S'il n'eXiste pas de tel nombre, la fonction doit renvoYer -1.\\Exemple:f(3, 9) = 8\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n", "entry_point": "choose_num", "completion": "    max_pair = -1\n    for i in range(X, Y+1):\n        if i % 2 == 0 and i > max_pair:\n            max_pair = i\n    return max_pair\n\n# Exemple d'utilisation\nprint(f(3, 9)) # Output: 8"}
{"task_id": "HumanEval/103", "prompt": "def f(N, M):\n\t\"\"\"Vous recevez deux eNtiers positifs N et M, et votre tâche coNsiste à calculer la MoyeNNe des eNtiers de N à M (y coMpris N et M). ArroNdissez la répoNse à l’eNtier le plus proche et coNvertissez-la eN biNaire. Si N est supérieur à M, reNvoie -1.\\Exemple:f(7, 1) = -1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n", "entry_point": "rounded_avg", "completion": "def f(N, M):\n    if N > M:\n        return -1\n    else:\n        average = round((N + M) / 2)\n        binary_average = bin(average)[2:]\n        return int(binary_average)\n\n# Exemple d'utilisation\nprint(f(7, 1)) # Output: -1"}
{"task_id": "HumanEval/104", "prompt": "def f(X):\n\t\"\"\"Étant donné une liste d’entiers positifs X. renvoie une liste triée de tous les éléments qui n'ont pas de chiffres pairs. Remarque : La liste renvoyée doit être triée par ordre croissant.\\Exemple:f([132, 98, 29]) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "unique_digits", "completion": "def f(X):\n    result = []\n    for num in X:\n        if all(int(digit) % 2 != 0 for digit in str(num)):\n            result.append(num)\n    return sorted(result)"}
{"task_id": "HumanEval/105", "prompt": "def f(ARR):\n\t\"\"\"Étant donné un tableau d'entiers, triez les entiers compris entre 1 et 9 inclus, inversez le tableau résultant, puis remplacez chaque chiffre par son nom correspondant parmi \"Un\", \"Deux\", \"Trois\", \"Quatre\", \"Cinq\". \", \"Six\", \"Sept\", \"Huit\", \"Neuf\".\\Exemple:f([2, 0, 52]) = ['Two']\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n", "entry_point": "by_length", "completion": "def f(ARR):\n    # Filtrer les entiers compris entre 1 et 9 inclus\n    filtered_arr = [x for x in ARR if x >= 1 and x <= 9]\n    \n    # Trier les entiers\n    sorted_arr = sorted(filtered_arr)\n    \n    # Inverser le tableau résultant\n    reversed_arr = sorted_arr[::-1]\n    \n    # Remplacer chaque chiffre par son nom correspondant\n    names_arr = []\n    for num in reversed_arr:\n        if num == 1:\n            names_arr.append(\"Un\")\n        elif num == 2:\n            names_arr.append(\"Deux\")\n        elif num == 3:\n            names_arr.append(\"Trois\")\n        elif num == 4:\n            names_arr.append(\"Quatre\")\n        elif num == 5:\n            names_arr.append(\"Cinq\")\n        elif num == 6:\n            names_arr.append(\"Six\")\n        elif num == 7:\n            names_arr.append(\"Sept\")\n        elif num == 8:\n            names_arr.append(\"Huit\")\n        elif num == 9:\n            names_arr.append(\"Neuf\")\n    \n    return names_arr\n\n# Exemple d'utilisation\nprint(f([2, 0, 52])) # ['Deux']"}
{"task_id": "HumanEval/106", "prompt": "def f(N):\n\t\"\"\"ImplémeNtez la foNctioN f qui preNd N comme paramètre et reNvoie uNe liste de taille N, telle que la valeur de l'élémeNt à l'iNdex i soit la factorielle de i si i est pair ou la somme des Nombres de 1 à i siNoN. je part de 1. la factorielle de i est la multiplicatioN des Nombres de 1 à i (1 * 2 * ... * i).\\Exemple:f(2) = [1, 2]\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n", "entry_point": "f", "completion": "def f(N):\n    result = []\n    for i in range(1, N+1):\n        if i % 2 == 0:\n            fact = 1\n            for j in range(1, i+1):\n                fact *= j\n            result.append(fact)\n        else:\n            result.append(sum(range(1, i+1)))\n    return result\n\n# Exemple d'utilisation\nprint(f(2)) # Output: [1, 2]"}
{"task_id": "HumanEval/107", "prompt": "def f(N):\n\t\"\"\"ÉtaNt doNNé uN eNtier positif N, reNvoie uN tuple coNteNaNt le Nombre de paliNdromes eNtiers pairs et impairs compris daNs la plage (1, N), iNclus.\\Exemple:f(8) = (4, 4)\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "even_odd_palindrome", "completion": "    even_palindromes = 0\n    odd_palindromes = 0\n    \n    for i in range(1, N+1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_palindromes += 1\n            else:\n                odd_palindromes += 1\n    \n    return (even_palindromes, odd_palindromes)"}
{"task_id": "HumanEval/108", "prompt": "def f(ARR):\n\t\"\"\"Écrivez une fonction f qui prend un tableau d'entiers et renvoie le nombre d'éléments dont la somme de chiffres est > 0. Si un nombre est négatif, alors son premier chiffre signé sera négatif : par ex. -123 a signé les chiffres -1, 2 et 3.\\Exemple:f([2]) = 1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "count_nums", "completion": "def f(ARR):\n    count = 0\n    for num in ARR:\n        if num < 0:\n            num = -num\n            while num > 0:\n                count += num % 10\n                num //= 10\n        else:\n            while num > 0:\n                count += num % 10\n                num //= 10\n    return count\n\n# Exemple d'utilisation\nprint(f([2])) # Output: 1"}
{"task_id": "HumanEval/109", "prompt": "def f(ARR):\n\t\"\"\"Nous avons un tableau 'ARR' de N entiers ARR[1], ARR[2], ..., ARR[N].Les nombres dans le tableau seront ordonnés aléatoirement. Votre tâche consiste à déterminer s'il est possible d'obtenir un tableau trié dans un ordre non décroissant en effectuant l'opération suivante sur le tableau donné : Vous êtes autorisé à effectuer une opération de décalage vers la droite un certain nombre de fois. Une opération de décalage à droite signifie décaler tous les éléments du tableau d’une position dans la bonne direction. Le dernier élément du tableau sera déplacé vers la position de départ dans le tableau, c'est-à-dire le 0ème index. S'il est possible d'obtenir le tableau trié en effectuant l'opération ci-dessus, retournez True, sinon retournez False. Si le tableau donné est vide, retournez True. Remarque : Il est garanti que la liste donnée contient des éléments uniques.\\Exemple:f([]) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n", "entry_point": "move_one_ball", "completion": "def f(ARR):\n    if not ARR:\n        return True\n    \n    sorted_ARR = sorted(ARR)\n    \n    for i in range(len(ARR)):\n        if ARR == sorted_ARR:\n            return True\n        ARR = [ARR[-1]] + ARR[:-1]\n    \n    return False\n\n# Test de la fonction\nprint(f([])) # True\nprint(f([1, 2, 3, 4, 5])) # True\nprint(f([5, 1, 2, 3, 4])) # True\nprint(f([3, 2, 1])) # False"}
{"task_id": "HumanEval/110", "prompt": "def f(LST, LST):\n\t\"\"\"Dans ce problème, vous allez implémenter une fonction qui prend deux listes de nombres et détermine s'il est possible d'effectuer un f d'éléments entre eux pour faire de LST une liste de nombres pairs uniquement. Il n'y a pas de limite sur le nombre d'éléments fd entre LST et LST. S'il est possible de placer des éléments entre LST et LST pour que tous les éléments de LST soient pairs, renvoyez \"OUI\". Sinon, renvoyez \"NON\".\\Exemple:f([6, 8, 5], [7, 5, 1]) = 'NO'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n", "entry_point": "exchange", "completion": "def f(LST1, LST2):\n    for num in LST1:\n        if num % 2 != 0:\n            return \"NON\"\n    return \"OUI\""}
{"task_id": "HumanEval/111", "prompt": "def f(TES):\n\t\"\"\"Étant donné une chaîne représentant des lettres minuscules séparées par des espaces, renvoie un dictionnaire de la lettre avec le plus de répétitions et contenant le nombre correspondant. Si plusieurs lettres ont la même occurrence, renvoyez-les toutes.\\Exemple:f(\"y\") = {'y': 1}\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n", "entry_point": "histogram", "completion": "def f(TES):\n    letter_count = {}\n    \n    # Compter le nombre d'occurrences de chaque lettre\n    for letter in TES:\n        if letter != ' ':\n            if letter in letter_count:\n                letter_count[letter] += 1\n            else:\n                letter_count[letter] = 1\n    \n    # Trouver le nombre maximum d'occurrences\n    max_count = max(letter_count.values())\n    \n    # Créer un dictionnaire avec les lettres ayant le nombre maximum d'occurrences\n    result = {key: value for key, value in letter_count.items() if value == max_count}\n    \n    return result\n\n# Exemple d'utilisation\nprint(f(\"y\")) # {'y': 1}"}
{"task_id": "HumanEval/112", "prompt": "def f(S, C):\n\t\"\"\"TâChe On nouS donne deux ChaîneS S et C, vouS devez Supprimer touS leS CaraCtèreS de S qui Sont égaux à n'importe quel CaraCtère de C puiS vérifier Si la Chaîne réSultante eSt un palindrome. Une Chaîne eSt appelée palindrome Si elle Se lit de la même manière verS l’arrière et verS l’avant. VouS devez renvoyer un tuple Contenant la Chaîne de réSultat et True/FalSe pour la vérifiCation.\\Exemple:f('i', 'i') = ('', True)\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n", "entry_point": "reverse_delete", "completion": "def f(S, C):\n    new_S = ''.join([char for char in S if char not in C])\n    if new_S == new_S[::-1]:\n        return (new_S, True)\n    else:\n        return (new_S, False)"}
{"task_id": "HumanEval/113", "prompt": "def f(LST):\n\t\"\"\"Étant donné une liste de chaînes, où chaque chaîne est composée uniquement de chiffres, renvoie une liste. Chaque élément i de la sortie doit être \"le nombre d'éléments impairs dans la chaîne i de l'entrée\". où tous les i doivent être remplacés par le nombre de chiffres impairs dans la iième chaîne de l'entrée.\\Exemple:f(['421']) = ['the number of odd elements 1n the str1ng 1 of the 1nput.']\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "odd_count", "completion": "def f(LST):\n    output = []\n    for string in LST:\n        count = 0\n        for char in string:\n            if char.isdigit() and int(char) % 2 != 0:\n                count += 1\n        output.append(f'the number of odd elements in the string {string} of the input is {count}.')\n    return output\n\n# Example\nprint(f(['421'])) # Output: ['the number of odd elements in the string 421 of the input is 1.']"}
{"task_id": "HumanEval/114", "prompt": "def f(NUMs):\n\t\"\"\"Étant donné un tableau de nombres entiers, trouvez la somme minimale de tout sous-tableau de nombres non vide.\\Exemple:f([6]) = 6\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n", "entry_point": "minSubArraySum", "completion": "    min_sum = float('inf')\n    current_sum = 0\n    \n    for num in NUMs:\n        current_sum = max(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum"}
{"task_id": "HumanEval/115", "prompt": "def f(GRI, CAP):\n\t\"\"\"Vous recevez une grille rectangulaire de puits. Chaque rangée représente un seul puits et chaque 1 d'une rangée représente une seule unité d'eau. Chaque puits possède un seau correspondant qui peut être utilisé pour en extraire l'eau, et tous les seaux ont la même capacité. Votre tâche consiste à utiliser les seaux pour vider les puits. Indiquez le nombre de fois dont vous avez besoin pour abaisser les seaux.\\Exemple:f([[4, 3, 4], [1, 2, 5]], 4) = 5\"\"\"\n", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n", "entry_point": "max_fill", "completion": "    count = 0\n    for row in GRI:\n        for num in row:\n            if num > CAP:\n                count += num // CAP\n                if num % CAP != 0:\n                    count += 1\n            else:\n                count += 1\n    return count\n\nprint(f([[4, 3, 4], [1, 2, 5]], 4)) # Output: 5"}
{"task_id": "HumanEval/116", "prompt": "def f(ARR):\n\t\"\"\"Dans ce Kata, vous devez trier un tableau d'entiers non négatifs en fonction du nombre de un dans leur représentation binaire par ordre croissant. Pour un nombre similaire de unités, triez en fonction de la valeur décimale. Il doit être implémenté comme ceci :\\Exemple:f([2, 3, 5, 5, 4]) = [2, 4, 3, 5, 5]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "sort_array", "completion": "    return sorted(ARR, key=lambda x: (bin(x).count('1'), x))"}
{"task_id": "HumanEval/117", "prompt": "def f(S, N):\n\t\"\"\"ÉtaNt doNNé uNe chaîNe S et uN Nombre Naturel N, vouS avez été chargé d'implémeNter uNe foNctioN qui reNvoie uNe liSte de touS leS motS de la chaîNe S qui coNtieNNeNt exactemeNt N coNSoNNeS, daNS l'ordre où ceS motS apparaiSSeNt daNS la chaîNe S. Si la chaîNe S eSt vide, la foNctioN doit reNvoyer uNe liSte vide. Remarque : vouS pouvez SuppoSer que la chaîNe d'eNtrée Ne coNtieNt que deS lettreS et deS eSpaceS.\\Exemple:f('g', 5) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n", "entry_point": "select_words", "completion": "def f(S, N):\n    words = S.split()\n    result = []\n    \n    for word in words:\n        consonants = 0\n        for letter in word:\n            if letter.lower() not in ['a', 'e', 'i', 'o', 'u', 'y']:\n                consonants += 1\n        if consonants == N:\n            result.append(word)\n    \n    return result\n\n# Exemple d'utilisation\nprint(f('g', 5)) # Output: []"}
{"task_id": "HumanEval/118", "prompt": "def f(WOR):\n\t\"\"\"On vous donne un mot. Votre tâche consiste à trouver la voyelle la plus proche qui se situe entre deux consonnes du côté droit du mot (sensible à la casse). Les voyelles du début et de la fin ne comptent pas. Renvoie une chaîne vide si vous n'avez trouvé aucune voyelle répondant à la condition ci-dessus. Vous pouvez supposer que la chaîne donnée contient uniquement une lettre anglaise.\\Exemple:f(\"asl\") = ''\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "get_closest_vowel", "completion": "def f(WOR):\n    vowels = \"aeiouAEIOU\"\n    consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    \n    found_vowel = ''\n    \n    for i in range(1, len(WOR)-1):\n        if WOR[i] in vowels:\n            for j in range(i+1, len(WOR)-1):\n                if WOR[j] in consonants:\n                    found_vowel = WOR[i]\n                    break\n            if found_vowel:\n                break\n    \n    return found_vowel\n\n# Exemple d'utilisation\nprint(f(\"asl\")) # Output: ''"}
{"task_id": "HumanEval/119", "prompt": "def f(LST):\n\t\"\"\"Vous recevez une liste de deux chaînes, les deux chaînes étant constituées uniquement de parenthèses ouvertes '(' ou de parenthèses fermées ')'. Votre travail consiste à vérifier s'il est possible de concaténer les deux chaînes dans un certain ordre, et que la chaîne résultante sera bonne. Une chaîne S est considérée comme bonne si et seulement si toutes les parenthèses de S sont équilibrées.\\Exemple:f((')', ')')) = 'No'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n", "entry_point": "match_parens", "completion": "def f(LST):\n    s = LST[0] + LST[1]\n    stack = []\n    \n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return 'No'\n            stack.pop()\n    \n    if len(stack) == 0:\n        return 'Yes'\n    else:\n        return 'No'"}
{"task_id": "HumanEval/120", "prompt": "def f(ARR, K):\n\t\"\"\"Étant donné un tableau ARR d'entiers et un entier positif K, renvoie une liste triée de longueur K avec les f K nombres dans ARR.\\Exemple:f([2, 1], 1) = [2]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n", "entry_point": "maximum", "completion": "    return sorted(ARR)[:K]"}
{"task_id": "HumanEval/121", "prompt": "def f(LST):\n\t\"\"\"Étant donné une liste d’entiers non vide, renvoie la somme de tous les éléments impairs qui sont en position paire.\\Exemple:f([6, 7]) = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n", "entry_point": "solution", "completion": "    sum = 0\n    for i in range(len(LST)):\n        if i % 2 == 0 and LST[i] % 2 != 0:\n            sum += LST[i]\n    return sum\n\n# Exemple d'utilisation\nprint(f([6, 7])) # Output: 0"}
{"task_id": "HumanEval/122", "prompt": "def f(ARR, K):\n\t\"\"\"Étant donné un tableau non vide d'entiers ARR et un entier K, renvoie la somme des éléments avec au plus deux chiffres parmi les K premiers éléments de ARR.\\Exemple:f([3], 4) = 3\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "add_elements", "completion": "    sum = 0\n    count = 0\n    \n    for num in ARR[:K]:\n        if abs(num) < 100:\n            sum += num\n            count += 1\n        if count == 2:\n            break\n    \n    return sum"}
{"task_id": "HumanEval/123", "prompt": "def f(N):\n\t\"\"\"ÉtaNt doNNé uN eNtier positif N, reNvoie uNe liste triée coNteNaNt les Nombres impairs daNs la séqueNce Collatz. La coNjecture de Collatz est uNe coNjecture eN mathématiques qui coNcerNe uNe suite défiNie comme suit : commeNcer par tout eNtier positif N. Alors chaque terme est obteNu à partir du terme précédeNt de la maNière suivaNte : si le terme précédeNt est pair, le terme suivaNt est la moitié du terme précédeNt. Si le terme précédeNt est impair, le terme suivaNt est 3 fois le terme précédeNt plus 1. La coNjecture est que quelle que soit la valeur de N, la séqueNce atteiNdra toujours 1. Remarque : 1. Collatz(1) est [1]. 2. liste reNvoyée triée par ordre croissaNt.\\Exemple:f(8) = [1]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "get_odd_collatz", "completion": "def f(N):\n    result = []\n    while N != 1:\n        if N % 2 == 0:\n            N = N // 2\n        else:\n            N = 3 * N + 1\n        if N % 2 != 0:\n            result.append(N)\n    result.sort()\n    return result\n\n# Exemple d'utilisation\nprint(f(8))  # Output: [1]"}
{"task_id": "HumanEval/124", "prompt": "def f(DAT):\n\t\"\"\"Vous devez écrire une fonction qui valide une chaîne de DAT donnée et renvoie True si la DAT est valide sinon False. La DAT est valide si toutes les règles suivantes sont satisfaites : 1. La chaîne de DAT n'est pas vide. 2. Le nombre de jours n'est pas inférieur à 1 ni supérieur à 31 jours pour les mois 1,3,5,7,8,10,12. Et le nombre de jours n'est pas inférieur à 1 ni supérieur à 30 jours pour les mois 4,6,9,11. Et le nombre de jours n'est pas inférieur à 1 ni supérieur à 29 pour le mois 2. 3. Les mois ne doivent pas être inférieurs à 1 ni supérieurs à 12. 4. La DAT doit être au format : mm-jj-aaaa\\Exemple:f(\"x\") = False\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n", "entry_point": "valid_date", "completion": "def f(DAT):\n    # Vérifier si la chaîne de DAT n'est pas vide\n    if DAT == \"\":\n        return False\n    \n    # Séparer la chaîne en mois, jour et année\n    date = DAT.split(\"-\")\n    \n    # Vérifier si la date est au format mm-jj-aaaa\n    if len(date) != 3:\n        return False\n    \n    # Extraire le mois, le jour et l'année\n    mois = int(date[0])\n    jour = int(date[1])\n    annee = int(date[2])\n    \n    # Vérifier si le mois est valide\n    if mois < 1 or mois > 12:\n        return False\n    \n    # Vérifier le nombre de jours en fonction du mois\n    if mois in [1, 3, 5, 7, 8, 10, 12]:\n        if jour < 1 or jour > 31:\n            return False\n    elif mois in [4, 6, 9, 11]:\n        if jour < 1 or jour > 30:\n            return False\n    elif mois == 2:\n        if (annee % 4 == 0 and annee % 100 != 0) or (annee % 400 == 0):\n            if jour < 1 or jour > 29\n        else:\n            if jour < 1 or jour > 28\n    \n    return True"}
{"task_id": "HumanEval/125", "prompt": "def f(TXT):\n\t\"\"\"Étant donné une chaîne de mots, renvoie une liste de mots divisés en espaces, si aucun espace n'existe dans le texte, vous devez diviser en virgules ',' si aucune virgule n'existe, vous devez renvoyer le nombre de lettres minuscules avec un ordre impair dans l'alphabet. , ord('a') = 0, ord('b') = 1, ... ord('z') = 25\\Exemple:f(\"p\") = 1\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n", "entry_point": "split_words", "completion": "    if ' ' in TXT:\n        return TXT.split(' ')\n    elif ',' in TXT:\n        return TXT.split(',')\n    else:\n        letters = [char for char in TXT if char.islower()]\n        odd_letters = [char for char in letters if ord(char) % 2 != 0]\n        return len(odd_letters)"}
{"task_id": "HumanEval/126", "prompt": "def f(LST):\n\t\"\"\"Étant donné une liste de nombres, indique s'ils sont triés ou non par ordre croissant. Si la liste contient plus d’un double du même numéro, renvoyez False. Supposons qu’il n’y ait pas de nombres négatifs et uniquement des nombres entiers.\\Exemple:f([4]) = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n", "entry_point": "is_sorted", "completion": "    if len(LST) <= 1:\n        return True\n    \n    for i in range(len(LST)-1):\n        if LST[i] >= LST[i+1]:\n            return False\n        \n    if len(set(LST)) < len(LST):\n        return False\n    \n    return True"}
{"task_id": "HumanEval/127", "prompt": "def f(INT, INT):\n\t\"\"\"Vous disposez de deux intervalles, chaque intervalle étant une paire d’entiers.\\Exemple:f((4, 3), (3, 6)) = 'NO'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n", "entry_point": "intersection", "completion": "def f(interval1, interval2):\n    if interval1[0] > interval2[1] or interval2[0] > interval1[1]:\n        return 'NO'\n    else:\n        return 'YES'"}
{"task_id": "HumanEval/128", "prompt": "def f(ARR):\n\t\"\"\"Vous recevez un tableau d'entiers et vous devez renvoyer la somme des grandeurs d'entiers multipliée par le produit de tous les signes de chaque nombre du tableau, représenté par 1, -1 ou 0. Remarque : renvoyez Aucun pour un tableau vide.\\Exemple:f([5, 2]) = 7\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "prod_signs", "completion": "def f(ARR):\n    if len(ARR) == 0:\n        return None\n    \n    somme = 0\n    produit_signes = 1\n    \n    for num in ARR:\n        somme += abs(num)\n        if num < 0:\n            produit_signes *= -1\n        elif num == 0:\n            produit_signes = 0\n    \n    return somme * produit_signes\n\n# Exemple d'utilisation\nprint(f([5, 2])) # Output: 7"}
{"task_id": "HumanEval/129", "prompt": "def f(GRI, K):\n\t\"\"\"Étant donné une grille avec N lignes et N colonnes (N >= 2) et un entier positif K, chaque cellule de la grille contient une valeur. Chaque entier compris dans la plage [1, N * N] inclus apparaît exactement une fois sur les cellules de la grille. Vous devez trouver le chemin minimum de longueur K dans la grille. Vous pouvez commencer à partir de n'importe quelle cellule et, à chaque étape, vous pouvez vous déplacer vers n'importe laquelle des cellules voisines, en d'autres termes, vous pouvez accéder aux cellules qui partagent un bord avec votre cellule actuelle. Veuillez noter qu'un chemin de longueur K signifie visiter exactement K cellules (pas nécessairement distinctes). Vous NE POUVEZ PAS sortir du réseau. Un chemin A (de longueur K) est considéré comme inférieur à un chemin B (de longueur K) si après avoir fait les listes ordonnées des valeurs sur les cellules que traversent A et B (appelons-les lst_A et lst_B), lst_A est lexicographiquement inférieur à lst_B, autrement dit, il existe un indice entier i (1 <= i <= K) tel que lst_A[i] < lst_B[i] et pour tout j (1 <= j < i) on a lst_A[ j] = lst_B[j]. Il est garanti que la réponse est unique. Renvoie une liste ordonnée des valeurs sur les cellules traversées par le chemin minimum.\\Exemple:f([[4, 4], [7, 6]], 5) = [1, 5, 1, 5, 1]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n", "entry_point": "minPath", "completion": "def f(GRI, K):\n    N = len(GRI)\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    def dfs(i, j, path):\n        if len(path) == K:\n            return path\n        \n        visited[i][j] = True\n        min_path = None\n        \n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if 0 <= x < N and 0 <= y < N and not visited[x][y]:\n                new_path = dfs(x, y, path + [GRI[x][y]])\n                if not min_path or new_path < min_path:\n                    min_path = new_path\n        \n        visited[i][j] = False\n        return min_path\n    \n    for i in range(N):\n        for j in range(N):\n            path = dfs(i, j, [GRI[i][j]])\n            if path:\n                return path"}
{"task_id": "HumanEval/130", "prompt": "def f(N):\n\t\"\"\"Tout le moNde coNNaît la séqueNce de FiboNacci, elle a été étudiée eN profoNdeur par les mathématicieNs au cours des deux derNiers siècles. CepeNdaNt, ce que les geNs Ne coNNaisseNt pas, c’est la séqueNce TriboNacci. La séqueNce TriboNacci est défiNie par la récurreNce : f(1) = 3 f(N) = 1 + N / 2, si N est pair. f(N) = f(N - 1) + f(N - 2) + f(N + 1), si N est impair.\\Exemple:f(2) = [1, 3, 2.0]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n", "entry_point": "tri", "completion": "    if N == 1:\n        return [1, 3, 2.0]\n    elif N % 2 == 0:\n        return [1] + [3] + [N / 2]\n    else:\n        return [f(N - 1)[0] + f(N - 2)[0] + f(N + 1)[0]] + [f(N - 1)[1] + f(N - 2)[1] + f(N + 1)[1]] + [f(N - 1)[2] + f(N - 2)[2] + f(N + 1)[2]]"}
{"task_id": "HumanEval/131", "prompt": "def f(N):\n\t\"\"\"ÉtaNt doNNé uN eNtier positif N, reNvoie le produit de l'impair f. ReNvoie 0 si tous les f soNt pairs.\\Exemple:f(7) = 7\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n", "entry_point": "digits", "completion": "    product = 1\n    for i in range(1, N+1, 2):\n        product *= i\n    if product % 2 == 0:\n        return 0\n    else:\n        return product\n\n# Exemple d'utilisation\nprint(f(7)) # Output: 7"}
{"task_id": "HumanEval/132", "prompt": "def f(STR):\n\t\"\"\"Créez une fonction qui prend en entrée une chaîne contenant uniquement des crochets. La fonction doit renvoyer True si et seulement s'il existe une sous-séquence valide de parenthèses où au moins une parenthèse dans la sous-séquence est imbriquée.\\Exemple:f(\"b\") = False\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n", "entry_point": "is_nested", "completion": "def f(STR):\n    stack = []\n    for char in STR:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n    \n    return len(stack) > 0\n\n# Exemple d'utilisation\nprint(f(\"b\")) # False\nprint(f(\"[[]]\")) # True\nprint(f(\"[[[]]]\")) # True\nprint(f(\"[[]]]\")) # False"}
{"task_id": "HumanEval/133", "prompt": "def f(LST):\n\t\"\"\"On vous donne une liste de numéros. Vous devez renvoyer la somme des nombres au carré dans la liste donnée, arrondissez d'abord chaque élément de la liste à l'int supérieur (plafond).\\Exemple:f([1]) = 1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "sum_squares", "completion": "    sum = 0\n    for num in LST:\n        sum += (num ** 2)\n    return sum"}
{"task_id": "HumanEval/134", "prompt": "def f(TXT):\n\t\"\"\"Créez une fonction qui renvoie True si le dernier caractère d'une chaîne donnée est un caractère alphabétique et ne fait pas partie d'un mot, et False dans le cas contraire. Remarque : « mot » est un groupe de caractères séparés par un espace.\\Exemple:f(\"f\") = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "check_if_last_char_is_a_letter", "completion": "    # Vérifier si le dernier caractère est alphabétique et n'est pas suivi d'une lettre\n    if TXT[-1].isalpha() and (len(TXT) == 1 or not TXT[-2].isalpha()):\n        return True\n    else:\n        return False\n\n# Exemple d'utilisation de la fonction\nprint(f(\"f\"))  # True\nprint(f(\"f \"))  # False\nprint(f(\"f g\"))  # True\nprint(f(\"f g \"))  # False"}
{"task_id": "HumanEval/135", "prompt": "def f(ARR):\n\t\"\"\"Créez une fonction qui renvoie le plus grand index d'un élément qui n'est pas supérieur ou égal à l'élément qui le précède immédiatement. Si aucun élément de ce type n’existe, renvoie -1. Le tableau donné ne contiendra pas de valeurs en double.\\Exemple:f([]) = -1\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n", "entry_point": "can_arrange", "completion": "def f(ARR):\n    max_index = -1\n    for i in range(1, len(ARR)):\n        if ARR[i] < ARR[i-1]:\n            max_index = i-1\n    return max_index\n\n# Exemple d'utilisation\nprint(f([])) # Output: -1"}
{"task_id": "HumanEval/136", "prompt": "def f(LST):\n\t\"\"\"Créez une fonction qui renvoie un tuple (a, b), où « a » est le plus grand des entiers négatifs et « b » est le plus petit des entiers positifs d'une liste. S'il n'y a pas d'entiers négatifs ou positifs, renvoyez-les comme Aucun.\\Exemple:f([2]) = (None, 2)\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "entry_point": "largest_smallest_integers", "completion": "def f(LST):\n    neg = None\n    pos = None\n    \n    for num in LST:\n        if num < 0 and (neg is None or num > neg):\n            neg = num\n        elif num > 0 and (pos is None or num < pos):\n            pos = num\n    \n    return (neg, pos) if neg is not None or pos is not None else (None, None)"}
{"task_id": "HumanEval/137", "prompt": "def f(A, B):\n\t\"\"\"Créez une fonction qui prend des entiers, des flottAnts ou des chAînes représentAnt des nomBres réels et renvoie lA plus grAnde vAriABle dAns son type de vAriABle donné. Renvoie Aucun si les vAleurs sont égAles. RemArque : Si un nomBre réel est représenté sous forme de chAîne, lA virgule flottAnte peut être . ou ,\\Exemple:f(4, 7) = 7\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "compare_one", "completion": "def f(A, B):\n    if type(A) == int and type(B) == int:\n        if A > B:\n            return A\n        elif B > A:\n            return B\n        else:\n            return None\n    elif type(A) == float and type(B) == float:\n        if A > B:\n            return A\n        elif B > A:\n            return B\n        else:\n            return None\n    elif type(A) == str and type(B) == str:\n        A = float(A.replace(',', '.'))\n        B = float(B.replace(',', '.'))\n        if A > B:\n            return A\n        elif B > A:\n            return B\n        else:\n            return None\n    else:\n        return None\n\n# Exemple d'utilisation\nprint(f(4, 7)) # Output: 7"}
{"task_id": "HumanEval/138", "prompt": "def f(N):\n\t\"\"\"Évaluer si le Nombre N doNNé peut être écrit comme la somme d'exactemeNt 4 Nombres pairs positifs\\Exemple:f(568) = True\"\"\"\n", "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n", "entry_point": "is_equal_to_sum_even", "completion": "    count = 0\n    for i in range(2, N, 2):\n        for j in range(i, N, 2):\n            for k in range(j, N, 2):\n                for l in range(k, N, 2):\n                    if i + j + k + l == N:\n                        count += 1\n    if count == 1:\n        return True\n    else:\n        return False\n\n# Exemple d'utilisation\nprint(f(568)) # Output: True"}
{"task_id": "HumanEval/139", "prompt": "def f(N):\n\t\"\"\"La factorielle brésilieNNe est défiNie comme : braziliaN_factorial(N) = N ! *(N-1) ! *(N-2) ! * ... * 1! où N > 0\\Exemple:f(2) = 2\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n", "entry_point": "special_factorial", "completion": "\n\tresult = 1\n\tfor i in range(1, N+1):\n\t\tfactorial = 1\n\t\tfor j in range(1, i+1):\n\t\t\tfactorial *= j\n\t\tresult *= factorial\n\treturn result\n\n# Exemple d'utilisation\nprint(f(2)) # Output: 2"}
{"task_id": "HumanEval/140", "prompt": "def f(TEX):\n\t\"\"\"Étant donné une chaîne de TEXe, remplacez tous les espaces par des traits de soulignement, et si une chaîne contient plus de 2 espaces consécutifs, remplacez tous les espaces consécutifs par - f(\"\\Exemple:f(\"tDl\") = 'tDl'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n", "entry_point": "fix_spaces", "completion": "    return TEX.replace(\" \", \"_\").replace(\"   \", \"-\") if \"   \" in TEX else TEX.replace(\" \", \"_\")"}
{"task_id": "HumanEval/141", "prompt": "def f(FIL):\n\t\"\"\"Créez une fonction qui prend une chaîne représentant le nom d'un fichier et renvoie « Oui » si le nom du fichier est valide, et renvoie « Non » sinon. Le nom d'un fichier est considéré comme valide si et seulement si toutes les conditions suivantes sont remplies : - Le nom du fichier ne doit pas contenir plus de trois chiffres ('0'-'9'). - Le nom du fichier contient exactement un point '.' - La sous-chaîne avant le point ne doit pas être vide et commence par une lettre de l'alphabet latin (« a » - « z » et « A » - « Z »). - La sous-chaîne après le point doit être l'une de celles-ci : ['txt', 'exe', 'dll']\\Exemple:f(\".tt.txt\") = 'No'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n", "entry_point": "file_name_check", "completion": "def f(FIL):\n    if FIL.count('.') != 1:\n        return 'Non'\n    \n    filename, extension = FIL.split('.')\n    \n    if len(extension) != 3 or extension not in ['txt', 'exe', 'dll']:\n        return 'Non'\n    \n    if not filename or not filename[0].isalpha():\n        return 'Non'\n    \n    if sum(1 for char in filename if char.isdigit()) > 3:\n        return 'Non'\n    \n    return 'Oui'"}
{"task_id": "HumanEval/142", "prompt": "def f(LST):\n\t\"\"\"\" Cette fonction prendra une liste d'entiers. Pour toutes les entrées de la liste, la fonction mettra au carré l'entrée entière si son index est un multiple de 3 et cubera l'entrée entière si son index est un multiple de 4 et non un multiple de 3. La fonction ne modifiera pas les entrées de la liste dont les index ne sont pas un multiple de 3 ou 4. La fonction doit alors renvoyer la somme de toutes les entrées.\\Exemple:f([2]) = 4\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n", "entry_point": "sum_squares", "completion": "    result = 0\n    for i in range(len(LST)):\n        if i % 3 == 0:\n            LST[i] = LST[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            LST[i] = LST[i] ** 3\n        result += LST[i]\n    \n    return result\n\n# Exemple d'utilisation\nprint(f([2])) # Output: 4"}
{"task_id": "HumanEval/143", "prompt": "def f(SEN):\n\t\"\"\"Vous recevez une chaîne représentant une phrase, la phrase contient des mots séparés par un espace et vous devez renvoyer une chaîne contenant les mots de la phrase originale, dont les longueurs sont des nombres premiers, l'ordre des mots dans la nouvelle chaîne. devrait être le même que celui d'origine.\\Exemple:f(\"t o \") = ''\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n", "entry_point": "words_in_sentence", "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef f(SEN):\n    words = SEN.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"task_id": "HumanEval/144", "prompt": "def f(X, N):\n\t\"\"\"Votre tâche est d'implémeNter uNe foNctioN qui va f l'eXpressioN X * N. La foNctioN reNvoie True si X * N est évalué à uN Nombre eNtier et False siNoN. X et N soNt tous deuX uNe représeNtatioN sous forme de chaîNe d'uNe fractioN et oNt le format suivaNt, <Numérateur>/<déNomiNateur> où le Numérateur et le déNomiNateur soNt des Nombres eNtiers positifs. Vous pouvez supposer que X et N soNt des fractioNs valides et N’oNt pas zéro comme déNomiNateur.\\Exemple:f('24/2', '61/2') = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n", "entry_point": "simplify", "completion": "def f(X, N):\n    num_X, den_X = map(int, X.split('/'))\n    num_N, den_N = map(int, N.split('/'))\n    \n    result = num_X * num_N / (den_X * den_N)\n    \n    return result.is_integer()"}
{"task_id": "HumanEval/145", "prompt": "def f(NUMs):\n\t\"\"\"Écrivez une fonction qui trie la liste d'entiers donnée par ordre croissant en fonction de la somme de leurs chiffres. Remarque : s'il existe plusieurs éléments avec une somme similaire de leurs chiffres, classez-les en fonction de leur index dans la liste d'origine.\\Exemple:f([3, 9, 2, -9, -13]) = [-9, 2, -13, 3, 9]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "order_by_points", "completion": "def f(NUMs):\n    def sum_of_digits(num):\n        if num < 0:\n            num = -num\n        return sum(int(digit) for digit in str(num))\n\n    return sorted(NUMs, key=lambda x: (sum_of_digits(x), NUMs.index(x)))"}
{"task_id": "HumanEval/146", "prompt": "def f(NUMs):\n\t\"\"\"Écrivez une fonction qui prend un tableau de nombres en entrée et renvoie le nombre d'éléments du tableau supérieurs à 10 et les premier et dernier chiffres d'un nombre sont impairs (1, 3, 5, 7, 9).\\Exemple:f([6]) = 0\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n", "entry_point": "specialFilter", "completion": "def f(NUMs):\n    count = 0\n    for num in NUMs:\n        if num > 10 and int(str(num)[0]) % 2 != 0 and int(str(num)[-1]) % 2 != 0:\n            count += 1\n    return count\n\n# Exemple d'utilisation\nprint(f([6])) # Output: 0"}
{"task_id": "HumanEval/147", "prompt": "def f(N):\n\t\"\"\"ON vous doNNe uN eNtier positif N. Vous devez créer uN tableau d'eNtiers a de loNgueur N. Pour chaque i (1 ≤ i ≤ N), la valeur de a[i] = i * i - i + 1. ReNvoie le Nombre de triplets (a[i], a[j], a[k]) de a où i < j < k, et a[i] + a[j] + a[k] est uN multiple de 3.\\Exemple:f(2) = 0\"\"\"\n", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n", "entry_point": "get_max_triples", "completion": "def f(N):\n    a = [i*i - i + 1 for i in range(1, N+1)]\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count\n\n# Exemple\nprint(f(2)) # Output: 0"}
{"task_id": "HumanEval/148", "prompt": "def f(PLA, PLA):\n\t\"\"\"Il y a huit planètes dans notre système solaire : la plus proche du Soleil est Mercure, la suivante est Vénus, puis la Terre, Mars, Jupiter, Saturne, Uranus, Neptune. Écrivez une fonction qui prend deux noms de planètes sous forme de chaînes planète1 et planète2. La fonction doit renvoyer un tuple contenant toutes les planètes dont les orbites sont situées entre l'orbite de la planète1 et l'orbite de la planète2, triées par proximité du soleil. La fonction doit renvoyer un tuple vide si planète1 ou planète2 ne sont pas des noms de planète corrects.\\Exemple:f('WxA', 'JRQl') = ()\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n", "entry_point": "bf", "completion": "def f(planete1, planete2):\n    planetes = ['Mercure', 'Venus', 'Terre', 'Mars', 'Jupiter', 'Saturne', 'Uranus', 'Neptune']\n    \n    if planete1 not in planetes or planete2 not in planetes:\n        return ()\n    \n    index1 = planetes.index(planete1)\n    index2 = planetes.index(planete2)\n    \n    if index1 < index2:\n        return tuple(planetes[index1+1:index2])\n    else:\n        return tuple(planetes[index2+1:index1])\n\n# Exemple d'utilisation\nprint(f('Venus', 'Mars')) # ('Terre',)\nprint(f('Mars', 'Venus')) # ('Terre',)\nprint(f('Mercure', 'Neptune')) # ('Venus', 'Terre', 'Mars', 'Jupiter', 'Saturne', 'Uranus')\nprint(f('Mercure', 'Pluton')) # ()"}
{"task_id": "HumanEval/149", "prompt": "def f(LST):\n\t\"\"\"Écrivez une fonction qui accepte une liste de chaînes comme paramètre, supprime les chaînes qui ont des longueurs impaires et renvoie la liste résultante avec un ordre trié. La liste est toujours une liste de chaînes et jamais un tableau de nombres, et elle peut contenir des doublons. L'ordre de la liste doit être croissant selon la longueur de chaque mot et vous devez renvoyer la liste triée selon cette règle. Si deux mots ont la même longueur, triez la liste par ordre alphabétique. La fonction doit renvoyer une liste de chaînes dans l'ordre trié. Vous pouvez supposer que tous les mots auront la même longueur.\\Exemple:f(['k', 'y', 'x', 'r']) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n", "entry_point": "sorted_list_sum", "completion": "def f(LST):\n    # Supprimer les chaînes de longueur impaire\n    LST = [mot for mot in LST if len(mot) % 2 == 0]\n    \n    # Trier la liste en fonction de la longueur des mots et de l'ordre alphabétique\n    LST.sort(key=lambda x: (len(x), x))\n    \n    return LST\n\n# Exemple d'utilisation\nprint(f(['k', 'y', 'x', 'r'])) # Output: []"}
{"task_id": "HumanEval/150", "prompt": "def f(N, X, Y):\n\t\"\"\"UN programme simple qui doit reNvoYer la valeur de X si N est uN Nombre premier et doit reNvoYer la valeur de Y siNoN.\\Exemple:f(2, 6, 3) = 6\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n", "entry_point": "x_or_y", "completion": "    prime = True\n    if N < 2:\n        prime = False\n    else:\n        for i in range(2, N):\n            if N % i == 0:\n                prime = False\n                break\n    \n    if prime:\n        return X\n    else:\n        return Y\n\n# Exemple d'utilisation\nprint(f(2, 6, 3)) # Output: 6"}
{"task_id": "HumanEval/151", "prompt": "def f(LST):\n\t\"\"\"Étant donné une liste de nombres, renvoie la somme des carrés des nombres impairs de la liste. Ignorez les nombres négatifs ou non entiers.\\Exemple:f([3, 2]) = 9\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n", "entry_point": "double_the_difference", "completion": "    sum = 0\n    for num in LST:\n        if num % 2 != 0 and num > 0 and num.is_integer():\n            sum += num ** 2\n    return sum"}
{"task_id": "HumanEval/152", "prompt": "def f(GAM, GUEs):\n\t\"\"\"Je pense que nous nous souvenons tous de ce sentiment lorsque le résultat d’un événement tant attendu est enfin connu. Les sentiments et les pensées que vous ressentez à ce moment-là valent vraiment la peine d’être notés et comparés. Votre tâche consiste à déterminer si une personne a correctement deviné les résultats d'un certain nombre de correspondances. Vous recevez deux tableaux de scores et de suppositions de longueur égale, où chaque index affiche une correspondance. Renvoie un tableau de même longueur indiquant la distance entre chaque supposition. S’ils ont bien deviné, la valeur est 0, et sinon, la valeur est la différence absolue entre la supposition et le score.\\Exemple:f([5, 1, 5], [3, 2, 0]) = [2, 1, 5]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "compare", "completion": "def f(GAM, GUEs):\n    distances = []\n    for i in range(len(GAM)):\n        distances.append(abs(GAM[i] - GUEs[i]))\n    return distances\n\n# Exemple d'utilisation\nprint(f([5, 1, 5], [3, 2, 0])) # Output: [2, 1, 5]"}
{"task_id": "HumanEval/153", "prompt": "def f(CLA, EXTs):\n\t\"\"\"Vous recevrez le nom d'une classe (une chaîne) et une liste d'EXTs. Les EXTs doivent être utilisées pour charger des classes supplémentaires dans la classe. La force de l'extension est la suivante : Soit CAP le nombre de lettres majuscules dans le nom de l'extension, et soit SM le nombre de lettres minuscules dans le nom de l'extension, la force est donnée par la fraction CAP - SM. Vous devriez trouver l’extension la plus forte et renvoyer une chaîne dans ce format : ClassName.StrongestExtensionName. S'il existe deux EXTs ou plus ayant la même force, vous devez choisir celle qui vient en premier dans la liste.\\Exemple:f('~', ['MxeOK', '920']) = '~.MxeOK'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n", "entry_point": "Strongest_Extension", "completion": "def f(CLA, EXTs):\n    def calculate_strength(ext):\n        cap_count = sum(1 for c in ext if c.isupper())\n        sm_count = sum(1 for c in ext if c.islower())\n        return cap_count - sm_count\n\n    strongest_ext = None\n    max_strength = float('-inf')\n\n    for ext in EXTs:\n        strength = calculate_strength(ext)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_ext = ext\n\n    return f\"{CLA}.{strongest_ext}\" if strongest_ext else None\n\n# Example\nprint(f('~', ['MxeOK', '920']))  # Output: '~.MxeOK'"}
{"task_id": "HumanEval/154", "prompt": "def f(A, B):\n\t\"\"\"On vous donne 2 mots. Vous devez renvoyer True si le deuxième mot ou l'une de ses rotAtions est une sous-chAîne du premier mot\\Exemple:f('apj', '') = True\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n", "entry_point": "cycpattern_check", "completion": "def f(A, B):\n    if not B:\n        return True\n    if len(B) > len(A):\n        return False\n    \n    for i in range(len(A)):\n        if A[i:] + A[:i] == B:\n            return True\n    \n    return False\n\n# Exemple d'utilisation\nprint(f('apj', ''))\nprint(f('apj', 'jp'))\nprint(f('apj', 'pja'))\nprint(f('apj', 'ajp'))\nprint(f('apj', 'xyz'))"}
{"task_id": "HumanEval/155", "prompt": "def f(NUM):\n\t\"\"\"Étant donné un entier. renvoie un tuple contenant respectivement le nombre de chiffres pairs et impairs.\\Exemple:f(2) = (1, 0)\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "even_odd_count", "completion": "    # Initialiser les compteurs\n    nb_pairs = 0\n    nb_impairs = 0\n    \n    # Convertir l'entier en une chaîne de caractères pour pouvoir itérer sur chaque chiffre\n    str_num = str(NUM)\n    \n    # Parcourir chaque chiffre de l'entier\n    for chiffre in str_num:\n        if int(chiffre) % 2 == 0:\n            nb_pairs += 1\n        else:\n            nb_impairs += 1\n    \n    # Retourner un tuple contenant le nombre de chiffres pairs et impairs\n    return (nb_pairs, nb_impairs)"}
{"task_id": "HumanEval/156", "prompt": "def f(NUM):\n\t\"\"\"Étant donné un entier positif, obtenez son équivalent en chiffres romains sous forme de chaîne et renvoyez-le en minuscules. Restrictions : 1 <= num <= 1 000\\Exemple:f(50) = 'l'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "int_to_mini_roman", "completion": "def f(NUM):\n    if NUM < 1 or NUM > 1000:\n        return \"Restrictions: 1 <= num <= 1,000\"\n    \n    roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l',\n        90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    result = ''\n    for value, numeral in sorted(roman_numerals.items(), reverse=True):\n        while NUM >= value:\n            result += numeral\n            NUM -= value\n    \n    return result.lower()"}
{"task_id": "HumanEval/157", "prompt": "def f(A, B, C):\n\t\"\"\"ÉtAnt donné lA longueur des trois Côtés d'un triAngle. Renvoie True si les trois Côtés forment un triAngle reCtAngle, FAlse sinon. Un triAngle reCtAngle est un triAngle dont un Angle est droit ou 90 degrés.\\Exemple:f(3, 2, 5) = False\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n", "entry_point": "right_angle_triangle", "completion": "\tif A**2 + B**2 == C**2 or A**2 + C**2 == B**2 or B**2 + C**2 == A**2:\n\t\treturn True\n\telse:\n\t\treturn False"}
{"task_id": "HumanEval/158", "prompt": "def f(WORs):\n\t\"\"\"Écrivez une fonction qui accepte une liste de chaînes. La liste contient différents mots. Renvoie le mot avec le nombre maximum de caractères uniques. Si plusieurs chaînes ont un nombre maximum de caractères uniques, renvoie celle qui vient en premier dans l'ordre lexicographique.\\Exemple:f(['e']) = 'e'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n", "entry_point": "find_max", "completion": "    max_unique_chars = 0\n    max_unique_word = ''\n    \n    for word in WORs:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique_chars:\n            max_unique_chars = unique_chars\n            max_unique_word = word\n        elif unique_chars == max_unique_chars:\n            max_unique_word = min(max_unique_word, word)\n    \n    return max_unique_word"}
{"task_id": "HumanEval/159", "prompt": "def f(NUM, NEE, REM):\n\t\"\"\"Vous êtes un lapin affamé et vous avez déjà un certain nombre de carottes, mais il vous faut maintenant en manger davantage pour compléter les repas de la journée. vous devriez rendre un tableau de [nombre total de carottes des marais après vos repas, nombre de carottes restantes après vos repas] s'il n'y a pas assez de carottes restantes, vous perdrez toutes les carottes restantes, mais vous aurez toujours faim.\\Exemple:f(8, 1, 9) = [9, 8]\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n", "entry_point": "eat", "completion": "def f(NUM, NEE, REM):\n    total_carottes = NUM + NEE\n    if total_carottes >= REM:\n        carottes_restantes = total_carottes - REM\n    else:\n        carottes_restantes = 0\n    return [total_carottes, carottes_restantes]"}
{"task_id": "HumanEval/160", "prompt": "def f(OPE, OPE):\n\t\"\"\"Étant donné deux listes, opérateur et opérande. La première liste contient des opérations algébriques de base et la deuxième liste est une liste d’entiers. Utilisez les deux listes données pour construire l'expression algébrique et renvoyer l'évaluation de cette expression. Les opérations algébriques de base : Addition ( + ) Soustraction ( - ) Multiplication ( * ) Division d'étage ( // ) Exponentiation ( ** )\\Exemple:f(['-', '+'], [8, 4, 3]) = 7\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "do_algebra", "completion": "def f(operators, operands):\n    expression = str(operands[0])\n    for i in range(1, len(operands)):\n        expression += operators[i-1] + str(operands[i])\n    \n    result = eval(expression)\n    return result\n\n# Exemple d'utilisation\nprint(f(['-', '+'], [8, 4, 3])) # Output: 7"}
{"task_id": "HumanEval/161", "prompt": "def f(S):\n\t\"\"\"VouS recevez une chaîne S. Si S[i] eSt une lettre, inverSez Sa caSSe du baS verS le haut ou vice verSa, Sinon gardez-la telle quelle. Si la chaîne ne contient aucune lettre, inverSez la chaîne. La fonction doit renvoyer la chaîne réSultante.\\Exemple:f(\"7_%\") = '%_7'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n", "entry_point": "solve", "completion": "def f(S):\n    result = \"\"\n    for char in S:\n        if char.isalpha():\n            if char.islower():\n                result += char.upper()\n            else:\n                result += char.lower()\n        else:\n            result += char\n    if result.isalpha():\n        return result[::-1]\n    else:\n        return result\n\n# Exemple d'utilisation\nprint(f(\"7_%\")) # Résultat attendu: '%_7'"}
{"task_id": "HumanEval/162", "prompt": "def f(TEX):\n\t\"\"\"Étant donné une chaîne « TEXe », renvoie sa chaîne équivalente au hachage md5. Si « TEXe » est une chaîne vide, renvoyez Aucun.\\Exemple:f(\"v\") = '9e3669d19b675bd57058fd4664205d2a'\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "string_to_md5", "completion": "import hashlib\n\ndef f(TEX):\n    if TEX == \"\":\n        return None\n    else:\n        return hashlib.md5(TEX.encode()).hexdigest()"}
{"task_id": "HumanEval/163", "prompt": "def f(A, B):\n\t\"\"\"ÉtAnt donné deux entiers positifs A et B, renvoie les chiffres pAirs entre A et B, pAr ordre croissAnt.\\Exemple:f(5, 5) = []\"\"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "generate_integers", "completion": "    result = []\n    for i in range(A, B+1):\n        if i % 2 == 0:\n            result.append(i)\n    return result\n\n# Exemple d'utilisation\nprint(f(5, 5)) # Output: []"}
